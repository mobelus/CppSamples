
# CppSamples
Small cpp Examples

Test **Test** *Test* Test

# CppSamples
Small cpp Examples


https://www.tutorialspoint.com/cplusplus/cpp_questions_answers.htm

C++ Interview Questions 

https://www.tutorialspoint.com/cplusplus/cpp_interview_questions.htm


# Optimization

### for cycle 

(*) ATTENTION ... Do NOT Use if you have to check size of the Array every time

```
// Works // Old but Gold
std::vector vec;

for(int i=0; i < vec.size(); ++i)
{
  int b = vec[i];
}

```

```
// A bit faster // Micro optimisation
for(int i=0, ilen = vec.size(); i < ilen; ++i)
{
  int b = vec[i];
}
```

### operator <

```
// Works // Old but Gold
bool compareFunc(const Param& lhs, const Param& rhs)
{
  bool res = false;
  if (lhs.param_1 < rhs.param_1)     { res = true; } else if(lhs.param_1 == rhs.param_1)
  {  if (lhs.param_2 < rhs.param_2 ) { res = true; } else if(lhs.param_2 == rhs.param_2)
    {  ...
      {
        res = lhs.param_N < rhs.param_N;
      }
    }
  }
  return res;
}
```

```
// Better
bool compareFunc(const Param& lhs, const Param& rhs)
{
  bool res = false;
  for (int i = 0, ilen = lhs.size(); i < ilen; i++)
  {
    if (lhsStr[i] < rhsStr[i])
    {
      res = true;
      break;
    }
    else if (lhsStr[i] == rhsStr[i])
      continue;
    else
      break;
  }
  return res;
}
```

```
// The Best
bool compareFunc(const Param& lhs, const Param& rhs)
{
  bool res = false;
  for (int i = 0, ilen = lhsStr.size(); i < ilen; i++)
  {
    if (lhsStr[i] == rhsStr[i])
      continue;

    res = lhsStr[i] < rhsStr[i];
    break;
  }
  return res;
}
```


### MUTABLE Relevant example (mutable mutex)

```
class MyClass : public QObject
{
  Q_OBJECT
public:
  MyClass();
  ~MyClass();
  state getState() const;
  
private:
  mutable QMutex _internalLock;
  States _state;
};
  
MyClass::MyClass(QObject* parent) : _internalLock {}
{
}

state MyClass::getState() const
{
  QMutexLocker locker(&_internalLock);
  return _state;
}
```


### Initialization over constructor with parameters

- Allows to write less code inside the body of the function
- const variables can be initialized in constructor and not inside the body of the class
- References can be passed only like that and not any other way

```
// Bad Solution

class MyClass
{
public:
  MyClass(int a, double d, SubClass& s)
  {
    _a = a;
    _d = 0.1; // (*) IMpossible here
    _s = s; // ???
  };
  
private:
  int _a;
  const double _d; // = 0.1; // (**) possible but not so good
  Subclass _s;
};
```

```
// Reason Solution and Best Strategy

class MyClass
{
public:
  MyClass(int a, double d, SubClass& s) : _a(a), _d(0.1), _s(s)
  { };
  
private:
  int _a;
  const double _d;
  Subclass _s;
};
```


### Problems

- access violation
- devision by zero
- out of range of array / memory


### Pure WinAPI solutions


### Lambda

```

[=](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression

[](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression

[&](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression

[this](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression

[this&](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression

```

+ ЗАМЫКАНИЯ



https://github.com/tumagonx/portabat


# QT to STD replacements

```
#include <vector>
#include <algorithm>

	template <class T> bool containsForStdVector ( std::vector<T> & v, T isThisIn)
	{
		//if (!v.contains(uaBrowseFolderNodeId.identifier.numeric)) // QT_VER
		return std::find(v.begin(), v.end(), isThisIn) != v.end();
	}
  
```


```
#include <random>
#include <iostream>
#include <sstream>


		unsigned int random_char()
		{
			std::random_device rd;
			std::mt19937 gen(rd());
			std::uniform_int_distribution<> dis(0, 255);
			return dis(gen);
		}

		std::string generate_hex(const unsigned int len)
		{
			std::stringstream ss;
			for (unsigned int i = 0; i < len; i++)
			{
				const auto rc = random_char();
				std::stringstream hexstream;
				hexstream << std::hex << rc;
				auto hex = hexstream.str();
				ss << (hex.length() < 2 ? '0' + hex : hex);
			}
			return ss.str();
		}

		void toUpper(std::string& s)
		{
			std::transform(s.begin(), s.end(), s.begin(), toupper);
		}

		void toLower(std::string& s)
		{
			std::transform(s.begin(), s.end(), s.begin(), tolower);
		}

		std::string uuidStdGenerate()
		{
			std::string strUUID = generate_hex(32 / 2);
			toUpper(strUUID);
			return strUUID;
		}
```

# Debug stuff by writing to a file with QT

```
	
	QString filename = "C:\\folder\\test.txt";
	QFile inFile(filename);
	inFile.open(QIODevice::ReadOnly | QIODevice::Text);
	QByteArray inputData = inFile.readAll();
	inFile.close();

	QFile file(filename);
	file.open(QIODevice::WriteOnly);
	QTextStream out(&file);
	out << inputData;
	out << "Thomas M. Disch: " << 334 << endl;
	file.close();

	/*
		QFile _file(filename);
		_file.cre
		QTextStream out(&_file);
		QString str = "123\n";
		out << str << endl;
	*/
```

# Виртуальные функции и деструктор

- Вритуальные методы в Конструкторе
При вызове виртуальных методов из коснутруктора используется **ПОЗДНЕЕ СВЯЗЫВАНИЕ**, как следствие мы не сможем вызвать . 

- Вритуальные методы в Деструкторе
При вызове виртуальных методов из деструктора компилятор использует не позднее, а **РАННЕЕ СВЯЗЫВАНИЕ**. 

https://habr.com/ru/post/64280/

# Исключения в контрукторах и деструкторах

- Исключени в Конструкторе
Если исключение не обработано, то c логической точки зрения разрушается объект, который еще не создан, а с технической, так как он еще не создан, то и деструктор этого объекта не будет вызван.
Если конструктор класса завершает работу исключением, значит он не завершает свою работу — следовательно объект не будет создан. Из-за этого могут возникать утечки памяти, т.к. для не полностью сконструированных объектов не будет вызван деструктор. Из-за этого распространено мнение, что конструктор никогда не должен вырабатывать исключения, однако это не так — утечки памяти возникнут не во всех случаях.

Стандарт языка С++ гарантирует, что если исключение возникнет в конструкторе, то памяти из под членов-данных класса будет освобождена корректно вызовом деструктора — т.е. если вы используете идиому RAII [2], то проблем не будет. Часто для этого достаточно использовать std::vector/std::string вместо старых массивов и строк, и умные указатели вместо обычных [3]. Если же вы продолжите использовать сырые указатели и динамически выделять память — нужно будет очень тщательно следить за ней, например в следующем фрагменте кода нет утечки, т.к. исключение будет выработано только если память не будет выделена [4]:


- Исключени в Деструкторе
Необработанное исключение в деструкторе вызовет размотку стека, что может привести к тому, что деструктор не выполнится полностью и объект полноценно не очстится из памяти +прочее неконтролируемое поведение. 

+ Нельзя бросать исключения во время обработки другого исключения (когда происходит раскрутка стека) — это приведет к аварийному завершению работы программы (фактически вызову abort()).

https://pro-prof.com/forums/topic/constructor_destructor_exceptions


# lvalue и rvalue

- Lvalue (locator value) представляет собой объект, который занимает идентифицируемое место в памяти (например, имеет адрес).

int var;
var = 4;

- Rvalue (locator value) это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти. (оно, не имеет адрес).

4 = var;       // ERROR!
(var + 1) = 4; // ERROR!

https://habr.com/ru/post/348198/

# Copy Constructor

- при передаче объекта класса в функцию, как параметра по значению (а не по ссылке);
- при возвращении из функции объекта класса, как результата её работы;
- при инициализации  одного объекта класса другим объектом этого класса.

# Что такое таблица виртуальных функций 

https://tproger.ru/problems/working-of-the-virtual-functions-in-c-plus-plus/

Виртуальная функция определяется vtable (виртуальной таблицей). Если какая-либо функция класса объявлена как виртуальная, создастся vtable, которая хранит адреса виртуальных функций этого класса. Для всех таких классов компилятор добавляет скрытую переменную vptr, которая указывает на vtable. Если виртуальная функция не переопределена в производном классе, vtable производного класса хранит адрес функции в родительском классе. Таблица vtable используется для получения доступа к адресу при вызове виртуальной функции. Механизм vtable позволяет реализовать динамическое связывание в C++.


Когда мы связываем объект производного класса с указателем базового класса, переменная vptr указывает на vtable производного класса. Это присвоение гарантирует, что будет вызвана нужная виртуальная функция.


# ТИПЫ С/CPP/WIN char, bool и BOOL
```
int sz = 0;
sz = sizeof(char); // = 1
sz = sizeof(wchar_t); // = 2
sz = sizeof(TCHAR); // = 2 typedef wchar_t WCHAR;

sz = sizeof(bool); 
sz = sizeof(BOOL); // typedef int BOOL;
```

# extern C
```
extern "C" {
#include <foo.h>
}

extern "C" {
    void foo() { }
}

 U __gxx_personality_v0
0000000000000000 T foo
```
вы получаете с рычага. Имя функции " foo "в объектном файле-это просто" foo", и у него нет всей причудливой информации о типе, которая исходит из искажения имени.

The extern "C" {} construct указывает компилятору не выполнять искажение имен, объявленных в фигурных скобках. Обычно компилятор C++ "улучшает" имена функций, чтобы они кодировали информацию о типе аргументов и возвращаемое значение; это называется исковеркали имя. Элемент extern "C" конструкция предотвращает искажение.

он обычно используется, когда код C++ должен вызывать библиотеку языка C. Он также может использоваться при предоставлении функции C++ (из DLL, для примеру) для клиентов c.


# extern C

вы должны использовать extern " C " в любое время, когда вы включаете функции определения заголовка, находящиеся в файле, скомпилированном компилятором C, используемом в файле C++. (Многие стандартные библиотеки C могут включать эту проверку в свои заголовки, чтобы упростить ее для разработчика)

например, если у вас есть проект с 3 файлами, util.c, util.ч, а основного.cpp и как .с и. файлы cpp компилируются с помощью компилятора C++ (g++, cc и т. д.), Тогда он действительно не нужен и может даже вызвать ошибки компоновщика. Если ваш процесс сборки использует обычный компилятор C для util.c, тогда вам нужно будет использовать extern "C" при включении util.з.

происходит то, что C++ кодирует параметры функции в ее имени. Вот как работает перегрузка функций. Все, что обычно происходит с функцией C, - это добавление подчеркивания ("_") к началу имени. Без использования extern "C" компоновщик будет искать функцию с именем DoSomething@@int@float () когда фактическое имя функции это _DoSomething () или просто DoSomething ().

использование extern "C" решает вышеуказанную проблему, сообщая компилятору C++, что он должен искать функцию, которая следует соглашению об именовании C, а не C++.


-----------------------------------------------
-----------------------------------------------
-----------------------------------------------

### Q. What is a signal? And how will it differ from event?
Что такое СИГНАЛЫ: События, которые могут обрабатываться НЕ лишь одним методом, а многими методами, тоесть слотами

Event - происходит один раз и завязан на одну обработку

### Q. What is a slot? And how it differs with callback Method?
Что такое СЛОТЫ: методы, которые мы "соединяем" с сигналами или (событиями), чтобы эти методы были выполнены в момент настцпления (emit) вызова / срабатывания события/сигнала

callback методы - просто указатели на функцию, по которым происходит её вызов.

### Q. What is the difference between signal and slot mechanism and Callback mechanism of GTK?



### Q. Есть список - нужно понять - Закальцован он или нет
A. 

# // TO DO //

1. использовать set
2. 
3. 


-----------------------------------------------
### Q: Какие типы умных указателей вы знаете ?
A: 
- unique_ptr, shared_ptr, weak_ptr 
- (auto_ptr, scoped_pointer, ... что-то ещё было)

-----------------------------------------------
```
auto_ptr - deprecated - реализовывал разрушающее копирование
vector<auto_ptr> v_ptrs;
<auto_ptr> p_a = v_ptrs[i]; // то что было в v_ptrs[i] теперь в p_a и v_ptrs[i] - невалидный
for(auto ptr : v_ptrs)
{
// на i-том невалидный указатель, свалимся
}

unique_ptr - запрещено копирование через
Приватный оператор присваивания и оператор копирования
, можно использовать только move():
// ПРИМЕР // ???

shared_ptr - ведёт подсчёт ссылок (может полявиться проблема циклических ссылок)

weak_ptr - избавляет от циклических ссылок
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Можно ли использовать shared_ptr в нескольких потоках ?
A: Да, но есть ограничения.
``` 
-----------------------------------------------
1. Разные потоки могут использовать один и тот же экземпляр shared_ptr,
но только если они не вызывают не констатнтые методы.
2. Для синхронизации одного экземпляра можно использовать атомарные функции.
3. То есть для увеличения/уменьшения счётчика ссылок нужно использовать
специальные атомарные фции, типа apomic_inctement / atomic_decrement.
``` 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Контейнеры библиотеки STL ?
A:
-----------------------------------------------
``` 
- Последовательные контейнеры
array - статический непрерывный массив 
vector - динамический непрерывный массив
deque - Двусторонняя очередь 
! forward_list - односвязный список 
list - двусвязный список  
- Ассоциативные контейнеры
set - Коллекция уникальных ключей, отсортированная по ключам 
map - Коллекция пар ключ-значение, отсортированная по ключам, ключи являются уникальными 
! multiset - Коллекция ключей, отсортированная по ключам 
! multimap - Коллекция пар ключ-значение, отсортированная по ключам 
- Неупорядоченные ассоциативные контейнеры
unordered_set - Коллекция уникальных ключей, хэш-ключами 
unordered_map - Коллекция пар ключ-значение, хэширован ключи, ключи являются уникальными 
! unordered_multiset - Коллекция ключей, хэш-ключами 
! unordered_multimap - Коллекция пар ключ-значение, хешируется по ключам 
- Адаптеры контейнеров
stack - реализует стек с помощью контейнера (LIFO структуры данных) 
queue - адаптируется контейнера обеспечивают очереди (FIFO структуры данных) 
! priority_queue - адаптация контейнеров для обеспечения приоритета очереди
- Специальные
! tuple
! circular_bufer
``` 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Разница между map и unordnered_map ?
A:
``` 
Внутренняя организация памяти внутри контейнеров.
map - красно-чёрное дерево.
unordnered_map - хеш-таблица
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Сложность операций всатвки в map ?
A:
``` 
Амортизированное О(1)
Коллизии нет  - О(1)
Коллизии есть - до О(N) формируются Бакеты
``` 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Сколько нужно мьютексов для получения dead_lock ?

A: Два

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Перечислите проблемы многопоточного программирования ?
A: 
``` 
- гонки потоков
- dead_lock / взаимная блокировка
- доступ к общим ресурсам / памяти
- Синхронизация Большого числа Клиентов / Серверов 
 // TO DO //
- "Проблема обедающих философов"
- "Проблема 10.000 клиентов" или "C10k-problem" - https://ru.wikipedia.org/wiki/C10k
``` 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Сложность операций с контейнером ?

A: См. Таблицу сложностей операций

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Многокомпонентные шаблоны проектирования ?
A: 

http://yarik-raider.blogspot.com/2010/01/mvc.html

https://habr.com/ru/post/215605/

- MVC - Model-View-Controller
- MVP - Model-View-Presenter
- MVVM - Model-View-View Model
- MVPVM - Model-View-Presenter-View Model

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Какие особенные контейнеры есть в библиотеке BOOST ?

1. Списки
- Массив
- Односвязный список
- Двусвязный список
- Список с пропусками
2. Деревья
- B-дерево
- Двоичное дерево поиска
- AVL-дерево
- Красно-чёрное деревоКуча
3. Графы
- Ориентированный граф
- Ориентированный ациклический граф
- Бинарная диаграмма решений
- Гиперграф
4. Прочие
- Хеш-таблица
- Стек

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@






-----------------------------------------------

# СТАНДАРТНЫЕ ЗАДАЧКИ

-----------------------------------------------
### Q: Переворот числа
A: IN 456   OUT 654
```
int reverse_int(int a)
{
  int b = 0
  int c = 0;
  for(int i = 0; a > 0; i++)
  {
    b = a % 10;
	a = a / 10;
	c = c * 10 + b;
  }
  
  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Переворот строки (указатель на char)
A: IN "abcde"   OUT "edcba"
```
void reverse_str(char* str)
{
    int len = strlen(str);
    for(i=0; i < (len/2); i++)
    {
        char temp = str[i];
        str[i] = str[ (len-1) - i];
        str[(len-1) - i] = temp;
    }
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Переворот строки (string)
A: IN "abcde"   OUT "edcba"
```
// v.1 BAD
#include <algorithm>
#include <string>

void reverse_str(std::string& s)
{
    for ( int i = 0, len = s.length(); i < (len/2); i++ )
    {
		std::swap(s[i], s[(len-1) - i]);
	}
}
```

```
// v.2 GOOD
#include <algorithm>
#include <string>

int main()
{
    std::string foo("foo");
	std::reverse(foo.begin(), foo.end());
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Сортировка пузырьком (Плохая)
A: IN "246135"   OUT "123456" 
```
// C
void bubble(int* a, int n)
{
  for (int i = n - 1; i > 0; i--)
    {
    for (int j = 0; j < i; j++)
      if (a[j] > a[j + 1])
      {
        int tmp = a[j];
        a[j] = a[j + 1];
        a[j + 1] = tmp;
      }
    }
}
```
```
// C++
template<typename T>
void bubble_sort(T array[], std::size_t size)
{
    for (std::size_t idx_i = 0; idx_i < size - 1; idx_i++)
    {
        for (std::size_t idx_j = 0; idx_j < size - idx_i - 1; idx_j++)
        {
            if (array[idx_j + 1] < array[idx_j])
            {
                std::swap(array[idx_j], array[idx_j + 1]);
            }
        }
    }
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Сортировка пузырьком (Улучшенная)
A: IN "246135"   OUT "123456" 
```
void bubbleSort(int* arrayPtr, int length_array) // сортировка пузырьком
{
 int temp = 0; // временная переменная для хранения элемента массива
 bool exit = false; // булевая переменная для выхода из цикла, если массив отсортирован
 
 while (!exit) // пока массив не отсортирован
 {
  exit = true;
  for (int int_counter = 0; int_counter < (length_array - 1); int_counter++) // внутренний цикл
    //сортировка пузырьком по возрастанию - знак >
    //сортировка пузырьком по убыванию - знак <
    if (arrayPtr[int_counter] > arrayPtr[int_counter + 1]) // сравниваем два соседних элемента
    {
     // выполняем перестановку элементов массива
     temp = arrayPtr[int_counter];
     arrayPtr[int_counter] = arrayPtr[int_counter + 1];
     arrayPtr[int_counter + 1] = temp;
     exit = false; // на очередной итерации была произведена перестановка элементов
    }
 }
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Факториал (Итеративный)
A: IN 5   OUT 125 (1*2*3*4*5) 
```
int my_fact(int b)
{
  if(b<0) return 0; // или ОШИБКА !
  
  int c = 1;
  for(int i=1; i<b+1; i++)
  {
    c = c * i;
  }
  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Факториал (Рекурсивный)
A: IN 5   OUT 125 (1*2*3*4*5) 
```
int my_fact(int num)  // вычисление факториала числа num
{
  if (num <= 1)
    return 1;  // если число не больше 1, возвращаем 1
  else
    return (num * fact(num - 1));  // рекурсивный вызов для числа на 1 меньше
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Возведение в степень (Итеративно) (Доп.)
A: IN 2^4   OUT 16 (2*2*2*2)
```
int my_pow(int x, unsigned int power) // num^pow
{
  if (power == 0) return 1;
  if (power == 1) return x;
  int n = 15;
  while ((power <<= 1) >= 0) n--;
  long tmp = x;
  while (--n > 0)
    tmp = tmp * tmp * (((power <<= 1) < 0) ? x : 1);
  return tmp;
}
```

-----------------------------------------------
### Q: Возведение в степень (Итеративно) (без учёта отрицательных тепеней)
A: IN 2^4   OUT 16 (2*2*2*2)
```
int my_pow(int n, unsigned int p) // num^pow
{
  int c = 1;
  for(int i=0; i<p; i++)
    c = n * c;
	
  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Возведение в степень (Итеративно) (с учётом отрицательных степеней)
A: IN 2^4    OUT 16 (2*2*2*2)

A: IN 2^-2   OUT 0  (1/4 = 1/(2*2))
```
int my_pow(int n, int p) // num^pow
{
  if(p<0) // 2^(-2) = 1/(2^2)
    p=(-1)*p;
   
  int c = 1;
  for(int i=0; i<p; i++)
  {
    c = n * c;
  }

  if(p<0) // 2^(-2) = 1/(2^2)
     c = 1 / c;

  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Возведение в степень (Улучшенный по скорости)
A: IN 2^6    OUT 64 (2*2*2*2*2*2)

A: IN 2^5    OUT 32 (2*2*2*2*2)
```
int my_pow(int n, int p) // num^pow
{
  if(p<0) // 2^(-2) = 1/(2^2)
    p=(-1)*p;

  int c = 1;
  if(p % 2 == 0) // степень чётная => возводим до половины и полвинное умножаем на само себя
  {
    for(int i=0; i<p/2; i++)
    {
      c = n * c;
    }
    c = c * c;
  }
  else // степень не чётная
  {
    for(int i=0; i<p; i++)
    {
      c = n * c;
    }
  }

  if(p<0) // 2^(-2) = 1/(2^2)
     c = 1 / c;

  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Возведение в степень (Рекурсивно)
A: IN 2^4   OUT 16 (2*2*2*2)
```
double my_pow(double x, int N)
{
  if(N < 0)
    return (1 / my_pow(x, -N));
  else if(N == 0)
    return 1;
  else if(N % 2 == 0)
  {
    double p = my_pow(x, N / 2);
    return (p * p);
  }
  else
    return ( my_pow(x, N – 1) * x );
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: (1) atio "своими руками" 
A: IN строка str="345"  OUT в число типа int n=435
```
int myAtio(std::string a = "456")
{
  int c = 0;
  int len = a.size();
  
  for(int i=0; i < len; i++)
  {
    c = c*10;
	switch(a[i])
	{
	  case '0': c=c+0; break;
	  case '1': c=c+1; break;
	  case '2': c=c+2; break;
	  case '3': c=c+3; break;
	  case '4': c=c+4; break;
	  case '5': c=c+5; break;
	  case '6': c=c+6; break;
	  case '7': c=c+7; break;
	  case '8': c=c+8; break;
	  case '9': c=c+9; break;
	}
  }
  return c;
}
```

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: (2) atio "своими руками" 
A: IN строка str="345"  OUT в число типа int n=435
```
int myAtio(std::string a = "456")
{
  int c = 0;
  int len = a.size();
  for(int i=0; i < len; i++)
  {
    c = c * 10;
	c = (a[i] - '0') + c;
  }
  return c;
}
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Из строки с пробелами удалить все пробелы в строке
A:
```
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Найти подстроку в строке
A:
```
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Факториал на Шаблонах
A:
```
template<unsigned N> struct factorial {
 static const unsigned value = N * factorial<N - 1>::value;
};
template<> struct factorial<0> {
 static const unsigned value = 1;
};

// Пример обращения:
const unsigned f5 = factorial<5>::value; // 120
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

-----------------------------------------------
### Q: Биномиальные коэффициенты на шаблонах
A:
```
template<unsigned N, unsigned K>
struct C {
 static const unsigned value =
 factorial<N>::value / factorial<K>::value / factorial<N–
K>::value;
};

// Пример обращения:
const unsigned i = C<5, 2>::value; // 10
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


-----------------------------------------------
### Q: Возведение в степень на шаблонах
A:
```
double pow(double x, int N)
{
  if(N < 0) return 1 / pow(x, -N);
  else if(N == 0) return 1;
  else if(N % 2 == 0)
  {
    double p = pow(x, N / 2);
    return p * p;
  }
  else return pow(x, N – 1) * x;
}
```

```
// ШАБЛОННАЯ ВЕРСИЯ

template<int N, typename T>
typename enable_if<(N < 0), T>::type
pow(T x){ return 1 / pow<-N>(x); }
template<int N, typename T>
typename enable_if<(N == 0), T>::type
pow(T x){ return 1; }
template<int N, typename T>
typename enable_if<(N > 0) && (N % 2 == 0), T>::type
pow(T x){ T p = pow<N / 2>(x); return p * p; }
template<int N, typename T>
typename enable_if<(N > 0) && (N % 2 == 1), T>::type
pow(T x){ return pow<N - 1>(x) * x; }

y = pow<3>(x); // Пример вызова
```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



# Идиома erase-remove 
Удалить все цифры 8 внутри числового вектора:
```
#include <algorithm>

vec.erase( std::remove( vec.begin(), vec.end(), 8), vec.end() );
```

# Q. Как удалить из VECTOR вектора с числами все 8-ки
A. Воспользоваться Идиомой erase-remove 
```
vec.erase( std::remove( vec.begin(), vec.end(), 8), vec.end() );

vector: { 1 2 3 1 2 3 1 2 3 }
1. вызов remove( v.begin(), v.end(), 2 ) удалит элементы со значением 2 из контейнера v
Удаление происходит по принципу сдвига:
Дошли до двойки: 1 2
Сдвинули тройку на место двойки: 1 3
Ищем дальше, добавляя элементы вектора и ставя по порядку после тройки:
1 3 1 2
Снова встретили двойку, ставим на её место следующий в векторе элемент, не равный двойке
1 3 1 3
И так далее до конца вектора
1 3 1 3 1 3 
Исходный вектор был длины 
Исходный  : 1 2 3 1 2 3 1 2 3
Текущий   : 1 3 1 3 1 3 ? ? ? оставляем на местах сдвинутых элементов невалидные значения вектора
Скорее всего там лежат: 1 2 3 те же значения, что и оставись в оригинальном векторе, но не факт.
remove() после того как сдвинул все элементы, возвращает указатель на ПЕРВЫЙ НЕВАЛИДНЫЙ элемент (то есть на первый ?)
2. вызов erase( первый ? , до конфа вектора ) - удалит из вектора все лишние невалидные значения
и останется только: { 1 3 1 3 1 3 }

```

# Q. Как удалить из LIST списка все числа равные 8-ке
A. вызвать list.remove() и всё.
```
list.remove( list.begin(), list.end(), 8);

list есть собственная реализация удаления объектов, list::remove и она быстрая.
- Элементы там не двигаются, а лишь переставляются ссылки.
- erase вызывать уже не нужно, потому что list::remove уничтожает ненужные элементы сам.
```




### Теоретический минимум для программиста

```
[Кросспост]

http://codeforces.com/blog/entry/1594?locale=ru

https://salykin-vladimir.ru/2015/07/questions-c-c-plus-plus/#.XHkPoPZuJaQ

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

СТРУКТУРЫ ДАННЫХ !!!

http://itedu.ru/courses/cpp/oop-in-cpp

 !!!!!!!!!!!!!!!!!
http://scrutator.me/post/2014/06/02/objects_memory_layout_p2.aspx

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

ЛЯМБДЫ:
Чтобы решить эту проблему, можно вручную указать возвращаемый тип лямбда-функии, используя синтаксис "-> тип":

 В общем случае его можно записать так:
[captures](arg1, arg2) -> result_type { /* code */ }
arg1, arg2
это аргументы. То, что передается алгоритмом в функтор (лямбду).
result_type
это тип возвращаемого значения. Это может показаться несколько непривычно, так как раньше тип всегда писали перед сущностью (переменной, функцией). Но к этом быстро привыкаешь.

[] - Название функции
() - 

[](double d) -> double { }

void func4(std::vector<double>& v) {
  std::transform(v.begin(), v.end(), v.begin(),
                 [](double d) -> double {
                   if (d < 0.0001) {
                     return 0;
                   }
                   else {
                     return d;
                   }
                 });
} 

Запись "[]" означает, что у функции нет имени, она безымянная, или, говоря по-другому, анонимная. Вместо "[]" можно мысленно подставлять имя "безымяннаяФункция",

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//////////////////  РАБОТА  ///////////////////////////////

CONNECT
Законектились - Сервер начинает нас слушать RECIEVE
Мы отправили эти данные SEND-ом.
Сервер проситал эти данные.
Прокол определён, сервер распарсил эту структуру.
Определил -> Что это запрос такого-то метода.
=> Выполнить этот метод на сервере.
И вернули ответ. SEND.

Пул Потоков - создали  Поток и внутри него 1 коннект между клиентом и счервером, и очередь сообщений / коннектов.
По одному потоку на 1 подсистему (1-го клиента) на 1 КОННЕКТ 
- в рамках коннекта делаем что нужно открыли соединение, закрыли соединение.
Все потоки ПАРАЛЛЕЛЬНО.
```

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
###  ОТ СТАСА ПРО WINDOWS  ///////////////////////////////

Процесс:
- контейнер для потоков
- то чему принадлежит память 
	Даже когда поток выделяет какую-то память, то это на самом деле память расположенное в адресном пространстве процесса, и эта память доступна ВСЕМ потокам

Объект Процесс - в Windows это объект ЯДРА.

Суть в том, что На ЛЮБОМ обекте ЯДРА можно ОЖИДАТЬ. ибо они ВСЕ могут находится в 2-ух состояниях - СИГНАЛЬНОЕ = Занят. НЕСИГНАЛЬНОЕ = Свободен.

Пример: Процесс - автообнолвения. Ждём и жержим ресурсы, пока не обновимся.

Поток, Мьютекс, Евент, Семафор:
	СИГНАЛЬНОЕ = Занят. НЕСИГНАЛЬНОЕ = Свободен.

Все потоки в процессе разделяют одно и тоже адресное пространство.
```
Память: У каждого процесса его адресное пространство ИЗОЛИРОВАННО
	Адрес виртуальный один и тот же, а по факту в физической памяти они РАЗНЫЕ
	Указатель в одном процессе  - адрес память в 1-ом процессе -> физич. память Ячейка_1
	Указатель в другом процессе - адрес память в 2-ом процессе -> физич. память Ячейка_2
```

На 1 виртуальный адрес  есть таблица Связи Виртуальныхи Физических адресов. 

На 1 ВИРТУАЛЬНЫЙ адрес в виртуальном адресном пространстве -> ссылка на Страницу физической памяти.

ВСЯ ПАМЯТЬ ПРОЦЕССА - Его виртуальое Адресное простраснство - ИЗОЛИРОВАНО от Адресных пространств всех Других процессов.

В Заголовке Файла: У него есть несколько СЕКЦИЙ - read/write read_only Execute_image ... 
				Смотрится эта секция, и сколько памяти нужно

### Можно ли себе выделить ЕЩЁ Больше Виртуальной памяти ?
Ответ: ДА !

WIRTUAL_ALLOC - выделяем предварително ДИАВПАЗОН Виртуальных адресов в адресном пространстве.
  (НА этом этапе только выделились адреса, НО НЕТ соответсвия с Физ.адресами на Диске)
  А потом MEM_COMMIT - Привязываем и работаем с этими адресами полноценно.

ПРОЦЕСС имеет 2 СТЕКА:
- Ядерный - 16 Килобайт
- Юзермодный - Большой ~1Мб (Или задаём параметром в фции CreateThread() )

Когда мы делаем ситемный вызов какого-то API - CreateEvent() = СИСТЕМНЫЙ ВЫЗОВ - происходит переключение в Режим Ядра
А это означает, что ECX, EAX, ESP .... что эти регистры, STACK_POINTER - Мы эту информацию в (?) частности передаём через Стек Ядерный.

Подгрузка регистров произойдёт по очереди

Плюс перейдя в режим Ядра, мы используем только этот стек для вызовов Функции, работает ядро со своими внутренними вызовами 
+нам нужен этот стек чтобы когда раскрутка стека началсь бы ОБРАТНО, у нас был бы обратный вызов в нашу функцию юзермодную, к тому кто вызывал.

call - достаёт из стека адрес возврата и передаёт управление на этот адрес возврата. В какой-то момент ПЕРЕКЛЮЧАЕТСЯ "КОНТЕКСТ"

Для этого есть структура CONTEXT - она загружает регистры изменённые в ядре, на значения регистров Юзермодные.
```
СТАРЫЙ СТЕК Ядерный с регистрами - зафиксировался.
// вызвали Ядерную функцию = СИСТЕМЕНЫЙ ВЫЗОВ
СЛЕПОК Стека изменённого после системного вызова возвращается обратно
// Продолжаем работать в Юзермодном Режимею.
```

Юзермодный Стек - страницы памяти - 20 Мегабайт задали, зарезевировалось адресное пространство, но страниц зарезервировалось 2 страницы, а не всё, что мы запросили.

Следовательно: Например, когда мы начали использовать Серьёзную Рекрсию. Что может выявить собой то, что Стек по виртуальным Адресам растёт и мы движемся всё дальше и выше.

Нашей виральыной памяти не поставлена в соответсвии Физическая память. => ОС дополниетльно начинает подгркжать страницы физич. памяти на это Виртуальное Адресное пространство.

В каждом приложении много потоков. И всем запросам передаётся не вся память, ибо они итак не расходуют ВСЁ за РАЗ.


Мьютекс - свободен мьютекс - переводим в СИГНАЛЬНОЕ состояние = НЕ ЗАНЯТ / СИГНАЛЬНОЕ - ЗАНЯТ.

Неэффективность Мьютексов - переключение контекста из Пользоват. в режим Ядра это ценно по врмеени слишком.
Эффектвиность Мьютексов - только то,что его можно использовать в рамках ОДНОГО Процесса.

Ядро это всегда посредник, и в рамках одного процесса, нет смылса задействовать ядро (ибо ЗАТРАТНО), если на то нет необходимости.

### События - С Автосбросом / Без Автосброса.
Waitфункция - Евент сделали Ресет - Евента НЕТ. 
10 потоков сделали WaitForSingleObkect() и в ещё одном потоке мы делаем 

### AUTORESET_EVENT
- SetEvent() -> просыпается ОДИН поток , которые выполнил WaitForSinlgeObject()
	Просыпается и этот Евент переводится в Несигнальное состояние Автоматически.

### MANUALRESET_EVENT
- SetEvent() -> просыпаются ВСЕ потоки , и в  Несигнальное состояние 
	событие надо было бы перевести ЯВНО вызвав ResetEvent().


### (?) ПАМЯТЬ WINDOWS: Одному процессу Можно или нельзя писать в память Другого процесса ?

МОЖНО - НО - Чтобы прочитать/записать что-то в другой процесс, нужно вызвать ЯВНО ReadProcessMemory() / WriteProcessMemory()
	передаём в функции ХЭНДЛ процесса, к которому у нас есть право доступа и указатель на участок адресного пространства в которое нам нужно пичать/читать.


(?) Есть HANDLE. Есть объект Ядра - Именованый Event. 
HANDLE = CreateEvent("Event_name"); // HANDLE - Дескриптор этого объекта Ядра. У каждого процесса есть таблица Дескрипторов.

Но получить доступ к этому объекту по ИМЕНИ евента ДРУГОЙ Процесс может открыть его по имени через OpenEvent();

Handle_1 = фактически актуальлен будет только в рамках одного нашего процесса (в которм мы его СОЗДАЛИ)

Handle_2 = фактически актуальлен будет только в рамках одного нашего процесса (в которм мы его ОТКРЫЛИ)


Мы не получили КОПИЮ Объекта. Мы просто получили Handle_2 - ИДЕКС в таблице Дескрипторов в рамках нашего процесса и более ничего, 
и только через дескриптор мы получаем доступ к самосу объекту, работая через системыне вызовы.


### (?) Как Получить доступ к Объекту Ядра Из Двух процессов:

1) Можно получить доступ - ОТКРЫТЬ обхект по ИМЕНИ.
2) можно получить доступ - по РОДИТЕЛЬСКОЙ связи.
3) Явный вызов функции	 - DUPLICATE_HANDLE()

(2) В CreateProcess() - мы имеем такую штуку, как INHERITABLE - параметр - можно ли этот объект НАСЛЕДОВАТЬ, тоесть Процесс может передать Чайлду Те Индексы в твблице дескрипторов, у которых при создании самих объектов мы выставили параметр INHERITABLE.

```
CreateProcess() // Paren
{
  // .. create some Kernel-Objects
  CreateProcess(INHERITABLE) // Child
  {
    // get all the HANDLE-s of created Inheritable Parent Handles
  }
}
```

### Что за параметр  ALTERABLE

Имеется в  WaitForSingleObjectEX(); EX !!!

ALTERABLE  - Для IPC процедур, она просыпается в тот момент, когда ты ожидаешь на каком-то фале и операция для записи - Когда асинхронная функуия выполнлось. и просыпается, если она выполняется.

Просыпается поток, которые ждёт на файле на каком-то

АСИНХРОННЫЙ вызов когда происходит - в тот момент, когда кто-то пишет или читает из Этого файла.


////////////////////////////////////////////////////////////
### СТРАНИЦЫ ПАМЯТИ - ДОСЛУШАТЬ

// TO DO

////////////////////////////////////////////////////////////
### 64-БИТНАЯ СРЕДА

- Всё больше весит за исключением типа chsr = 1 байту всегда и во всех версиях.
- Переадресация Реестра и Файловой системы - SysWOW64
- Для работы в ней, есть специальные версии всех СИСТЕМНЫХ ВЫЗОВОВ / Функций
- Адресное Пространство Выделяемое под процесс - есть указатель, который ограницен определённым числом

```
32 битная машина использует указатель = 4  Гигабайта = 2^32 байт
64 битная машина использует указатель = 16 Экзобайт = 2^64 байт = 64 ТЕРАБАЙТА (гига, тера, пета, экзо)
//	гигабайт	Гбайт	109	
//	терабайт	Тбайт	1012
//	петабайт	Пбайт	1015
//	эксабайт	Эбайт	1018
```

////////////////////////////////////////////////////////////
### WINDBG - DMP - Дампы - Анализ Дампов

UserMode отладчик   - OlieDBG 

KernelMode отладчик - WinDBG - можно ммотреть регистры, отадчивать, переменные, можно отлаживать как Юзер Мод программы, так и Кернел мод программы.

////////////////////////////////////////////////////////////
# СУРРОГАТНЫЙ ПРОЦЕСС в СОМ

http ://www.k-press.ru/cs/2002/1/surrogat/surrogat.asp
https://www.osp.ru/winitpro/2001/03/174740/
https://rsdn.org/article/com/introcom.xml

Суррогатные процессы в COM**

Василий Кораблев Вступление

Реализация COM - сервера в виде in - process(DLL) сервера дает значительные преимущества, например, лучшую структуризацию проекта, раздельную компиляцию модулей, возможность повторного использования модулей и т.п.Но в использовании внутрипроцессного(in - process) сервера есть одно небольшое, но порой критичное неудобство.Их невозможно создавать и вызывать по сети.Решить эту проблему помогают суррогатные процессы.

Формально, суррогатный процесс – это процесс, который порождается специальным EXE - модулем.Отличительной особенностью суррогатный процесса является то, что в него можно загрузить внутрипроцессный COM - сервер.Что же дает использование суррогатных процессов ?

Суррогатный процесс позволяет превратить внутрипроцессный сервер в полноценное DCOM - приложение, давая возможность вызывать компоненты этого сервера удаленно.

Суррогатные процессы позволяют изолировать компонент от клиента, тем самым исключая влияние на него таких критических ошибок, как проходы по памяти или утечки памяти во внутрипроцессном сервере.Таким образом, запуская компоненты в суррогатном процессе, клиент может защитить себя от возможно сбойного серверного кода при доступе к сервисам, предоставляемым сервером.

Один суррогатный процесс может обслуживать нескольких клиентов одновременно.

DLL внутрипроцессного сервера, запущенная в суррогатном процессе, получает все настройки контекста безопасности, установленные для суррогатного процесса.

Возможность использования так называемых системных суррогатных процессов, а также создания пользовательских суррогатных процессов появилась в Windows NT 4.0 SP2 и Windows 95 (с установленным DCOM).

Системный суррогатный процесс.

Идея, стоящая за суррогатными процессами COM – независимость способа реализации сервера от способа его активации.Суррогатные объекты реализуются в формате DLL, но могут быть активированы как внепроцессные серверы.Чтобы разрешить DLL активироваться внутри суррогатного процесса, нужно всего лишь добавить в реестр несколько дополнительных ключей, которые COM SCM(Service Control Manager COM, читается как «скам») просматривает при обслуживании запроса на активацию сервера.Эти ключи могут быть добавлены авторами клиентского кода для недопущения загрузки объекта с потенциально опасным кодом внутрь своего процесса или для удаленного запуска внутрипроцессных серверов через сеть...

////////////////////////////////////////////////////////////

```
(???) PRIVATE наследование Классов:


(???)
Каков размер объекта Foo: 
Каков размер объекта Bar: 

Для 32-битной платформы:
Foo: размер указателя int* = 4 байта 
	 (базовый класс указателя на наследников нет) 
	 + выравнивание кратное 4-ём
Bar: размер указателя char* = 4 байта 
	 + (указатель на класс наследник НЕ БУДЕТ УЧТЁН, ибо наследование было НЕВИРТУАЛЬНОЕ!!!)
	 + выравнивание кратное 4-ём

class Foo
{
public:
    Foo(int j) { i = new int[j]; }
    ~Foo() { delete i; }
private:
    int* i;
};

class Bar : Foo
{
public:
    Bar(int j) { i = new char[j]; }
    ~Bar() { delete i; }
private:
    char* i;
};

void main()
{
    Foo* f = new Foo(100);
    Foo* b = new Bar(200);

	*f = *b;

    delete f;
    delete b;
}

////////////////////////////////////////
Размер базового класса.
Размер класса также включает размер непосредственного родительского класа.

class D
{
 private:
   int i1;      // 4 байта
   int i2;      // 4 байта
};
 
class E : public D
{
 private:
   int k;       // 4 байта
};
В этом случае класс размер класса E будет равен 12 байтам.



////////////////////////////////////////
(???) СТАС - Чтобы число умножить на 2 - Логическая операция побитовая какую операцию можно применить 

http://informatics.mccme.ru/mod/book/view.php?id=5510&chapterid=496
```

////////////////////////////////////////
### (???) Бросать исключения в Конструкторе это НОРМАЛЬНО ?

Так как конструктор полностью не выполнился. Объект полностью не сформировался 
=> утечки памяти, если не отработал конструктор НЕ БУДЕТ. Следовательно можно не вызывать delete.
(*) Если мы до того не понаделали всяких MALLOC-ов внутри конструктора или до него в переменной / конструкторе

###  (!!!) Относится ко ВСЕМ объектам Ядра:
В случае если семафор используется внутри одного процесса, можно создать его без имени,
передав в качестве lpName значение NIL. Имя семафора не должно совпадать с именем уже существующего
объекта типов event, mutex, waitable timer, job или file-mapping.


### (?) Мьютекс - что это и для чего нужен.
Нужен для блокировки доступа стороннего потока к защищаемому от доступа семафором участка кода /
того участка кода как правило, внутри которго происходит обращение к какому-то общему ресурсу, который нужен Множеству потоков

### (?) Как происходит "БЛОКИРОВКА" стороннего потока мьютексом ? на вечно ли ? Ставятся ли потоки в очередь ?

### (?) Что делать, если поток заблокировал Мьютекс, началось на нём ожидание, и "забыл" выполнить его UNLOCK
или поток вообще УПАЛ (из-за ошибки / необработанного исключ.) / другой поток его прибил TerminateThread-ом ?
Что тогда будет с рассматриваемым (залоченным) Мьютексом ?

Ответ: Так как поток, в котором был создан / залочен Мьютекс перестал существовать, то и мьтекс освободится.
  Поток - объект ядра. И само же ядро следит за тем, чтобы освободить (отпустится) внутри умершего потока все прочие объекты ядра.
```
НЕСИГНАЛЬНОЕ СОСТОЯНИЕ Мьютекса - Мьютекс залочен потоком (чей-то)
  СИГНАЛЬНОЕ СОСТОЯНИЕ Мьютекса - Мьютекс освобождён потоком (ничей)
```
(?) Если мы Перевели Мьютекс в НЕсигнальное состояния внутри нашего потока, ТО разлочить этот мьютекс, 
тоесть перевести его в Сигнальное состояние извне (то есть из какого-либо другого потока) нельзя, это верно ?

Вопрос: Тоесть Стас, можно ли из другого потока сделать вызов OpenMutex() и выполнить в другом потоке ReleaseMutex ?
ОТВЕТ: НЕЛЬЗЯ - ReleaseMutex выбросит Ошибку, если вызывающий её поток не является Владельцем Мьютекса!!!!!
Поток становится его хозяином до тех пор, пока явно не освободит мьютекс функцией ReleaseMutex, или же не завершится.

Замечение: Запрет запуска второго экземпляра программы - вызываем CreateMutex, смотрим ERROR_ALREADY_EXISTS
если GetLastError вернул нам именно такой флаг, значит программа уже запущена.

### 5) Lock Free - ???

### 6) Spin Lock - ???
Спин-локи в ЯДРЕ, спин это бесконечный цикл for() / while() он в очень высокой частостотой запрашивает состояние
разделяемого ресурса, и постоянно запрашивает. Он не засыпает, он использует процессорное время постоянно, не
заплатив никапельки. Их использовать нужно на очень коротких учасках кода - ибо остальные из-за того, что спинлок
будет отбирать на себя всё процессорное время они протсо будут ждать.

### 7) InterLocked функции - ???

### 8) Семафор  представляет собой объект, позволяющий синхронизировать работу двух или нескольких процессов или потоков.
Для программиста семафор - это просто счетчик. Если счетчик равен N, это означает, что к ресурсу имеют доступ N процессов. 
Счетчик текущего числа ресурсов, максимальное , сколько потоков/процессов могут получить доступ к ресурсу одновременно.
- когда счетчик текущего числа ресурсов становится больше 0, семафор - в СВОБОДНОМ СОТОЯНИИ
- если этот счетчик равен 0, семафор ЗАНЯТ

// Уменьшаем счетчик семафора. Если к этому моменту уже запущено
// MAX_THREAD_COUNT потоков — счетчик равен 0 и семафор в
// несигнальном состоянии. Ожидаюшие потоки будут заморожены до завершения
// одного из запущенных ранее.
   WaitForSingleObject(Semaphore, INFINITE);
  
// Здесь располагается код, отвечающий за функциональность потока - загрузка файла
 
// Поток завершил работу, увеличиваем счетчик семафора и позволяем
// начать обработку другим потокам.
   ReleaseSemaphore(Semaphore, 1, NIL);

ПРИМЕР: SEMAPHORE - WaitForSingleObject   
   http://www.firststeps.ru/mfc/winapi/r.php?117
   
###  9) Критическая секция - Крит секция это объект ПОЛЬЗОВАТЕЛЬСКОГО режима. А Мьютекс это объект ЯДРА.
Особенности: Каждая операция с Мьютексом - захват, освобождение - требует переключение конткестного режима из пользовательского режима в контекст ядра.

Тоесть тратися время на сохраненеие регистров потока пользовательского режима, что-то свопается, что-то сохраняется. ЭТО ДОРОГО.
У КРИТ.СЕКЦИИ - всё находится и происходит в рамках пользовательского процесса / режима, тоесть в ядро перехода напрямую не происходит.
ОСОБЕННОСТЬ: - Так как Мьютекс объект ядра, а значит доступен всем процессам, что означает, что шарить мьютекс между процессами можно по имени.

- А Критическая Секция доступна в рамках ТОЛЬКО ОДНОГО Процесса. (Мьютекс тоже можно использовать так, но он более "мобильный")
ОГОВОРКА: ЕСЛИ есть Критическая Секция - множество потоков пытаются в неё войти, а кто-то один её залочил и потоки ждут ДОЛГО.
Так как "ПОД КАПОТОМ" этой Крит.Секции спрятан Мьютекс - Который ЗАХВАТЫВАЕТСЯ тогда, когда уровень критического ожидания входа в Крит.Секцию является Достаточно большим.

(??? СТАС) Кто определяет, на сколько Долгий интервал ожидания и когда будет задействован "подкапотный" Мьютекс

###  10) Wait-функции WaitForMultipleObjects:
Как вы помните, для синхронизации потоков, обычно требуется временно приостановить выполнение одного из потоков.
- При переводе средствами операционной системы в состояние ожидания, "ожидающий" поток НЕ ЗАНИМАЕТ процессорное время.
- Если флаг bWaitAll равен FALSE, функция вернет управление, как только хотя бы один из объектов подаст сигнал.
А если флаг равен TRUE, это произойдет только тогда, когда сразу все объекты начнут сигнализировать
(как мы увидим, это важнейшее свойство этой функции).


////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
 
https://www.youtube.com/watch?v=7KIIKrN9Pf8 
```
ЗАДАЧА: Реализовать очередь с приоритетом (последовательно)

Взять массив - долгие операции О(n)
Дерево, Куча или stack_list - О(log(n)) логарифмическое время для выполнения этих операция 
linked_list - связный список (вставка = О(n/2), а удаление О(1))

Вопрос будет таков: Принципиально ли нам иметь время вставки О(log(n)), или мы
можем пожертвовать в пользу более быстрого удаления элемента, чтобы удалять за О(1)
ЕСЛИ НАМ важно часто удалять из очереди приоритетов ?
```

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

Аутентификация - клиент-серверная часть.
gina-dll / credential_provider / security provider
На JAVA разрабатывался и дорабатывался сервер.
через библиотеку Tshrift <-> С Джава-Сервером
Контролер домена свой.

Т.е. человек И именно в Windows встраивались механизмы
- аутентификации
- заведения новой пользовательской учётной записи
- вывод различных кастомизироыванных сообщений, разновго вида / ошибка / предупреждение / справка
- защита от перехвата, организовывалась через подппись и шифрование base64

(??? СТАС) Защита от перехвата вводимых логина и пароля

(??? СТАС) Защита от подделки отклика (перехват отправленного до сервера) - подпись 

STL / Boost:

STL: контейнеры, алгоритмы.
Boost: 
- split, is_any_of, toupper, tolower, shared_ptr, noncopyable, property_tree::ptree, RNGs, circular_buffer

3. из boost - а использовал, от того, что чаще всего, к тому, что реже всего :
3.1 некоторые вещи для удобства работы со строками - boost::algorithm::split, boost::is_any_of, boost::toupper
3.2 boost::shared_ptr, boost::noncopyable // shared_ptr -> 11 стандарт.
3.3 boost::property_tree::ptree - xml-ный тамошний парсер
3.4 И использовал тамошние генераторы случайных чисел. Исследовал их свойства в своей дипломной работе в институте.
3.5 И однажды поигрался с циркулярным буфером

MFC - разработка интерфейса. GUI-приложение.

COM / DCOM:
- написание COM-сервера
- взаимодействие с БД через OLEDB


////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

Блиц:
1. - 2^8 = 256
2. - диапазон 4ё-х байтового числа = -(2^31)-1 - +(2^31)-1 

### Чтобы число умножить на 2 какую логическую побитовую операцию можно применить 
Ответ: ПОБИТОВЫЙ СДВИГ Влево
```
Пример с нечётными:
0000 0011 = 3
0000 0110 = 6

Пример с стпенями двойки:
0000 0001 = 2^0 = 1
0000 0010 = 2^1 = 2
0000 0100 = 2^2 = 4
0000 1000 = 2^3 = 8
0001 0000 = 2^4 = 16
0010 0000 = 2^5 = 32
0100 0000 = 2^6 = 64
1000 0000 = 2^7 = 128
```

### Чему равен размер указателя ? 
- В зависимости от платформы. 4ём байтам какой максиманый размер оперативки можно адресовать ?

### К какому верхнему адресу можно обратиться, если иметь доступ ко всему адресному пространству ?
- Указатель в зависимости от платформы - 64битный платформе он 8 байт занимает, на 32 битной 4 байта.

### Бросать исключения в Конструкторе это НОРМАЛЬНО ?
Да это НОМРАЛЬНО - и память НЕ утечёр ибо объект ещё не создался, ибо конструктор полностью не отработал

### Бросать Исключение в Деструкторе НЕБЕЗОПАСНО
В процессе обработки исключения, исключение не может исходить из самого деструктора, так как это считается ошибкой в работе механизма обработки исключений, приводящей к вызову std::terminate(); Однако деструктор может обрабатывать исключения, которые генерируются вызываемыми им функциями, сам же деструктор не должен возбуждать исключений.

https://habrahabr.ru/post/59349/

```
class Cnt {
private:
  X *xa;
  X *xb;
public:
  Cnt(int a, int b) {
    cout << "Cnt::Cnt" << endl;
    xa = new X(a);
    xb = new X(b);
  }
  ~Cnt() {
    cout << "Cnt::~Cnt" << endl;
    delete xa;
    delete xb;
  }
};
```
Казалось бы, ничего не забыли. (Хотя, строго говоря, конечно забыли как 
минимум конструктор копирования и операцию присвоения, которые бы корректно
работали с нашими указателями; ну да ладно.)

Воспользуемся этим классом:
```
try {
  Cnt c(1, 0);
} catch (...) {
  cout << "error" << endl;
}

И разберёмся, что и когда будет конструиваться и уничтожаться.

Сперва запустится процесс создания объекта Cnt.
В нём будет создан объект *xa
Начнёт создание объекта *xb...
… и тут произойдёт исключение

Всё. Конструктор прекратит свою работу, а деструктор объекта Cnt 
вызван не будет (и это правильно, объект-то не создался). Итого, что мы имеем? 
Один объект X, указатель на который (xa) навсегда потерян. 
В этом месте мы сразу получаем утечку памяти, а возможно, получаем утечку 
и более ценных ресурсов, соктов, курсоров...

Обратите внимание, что это одна из самых неприятных ситуаций, утечка возникает 
не всегда, а только при определённых аргументах (первый — не ноль, а второй — ноль).
Отыскать такие утечки бывает очень сложно.

Очевидно, такое решение годится только для очень простеньких программок, 
которые в случае любого исключения просто беспомощно валятся и всё.

Самое простое, надёжное и естественное решение — хранить объект по значению

Пример:

class Cnt {
private:
  X xa;
  X xb;
};
```

////////////////////////////
### Что выведется на экран:

```
struct A0
{
  A0()
  { printf("A0"); }
  virtual ~A0()
  { printf("~A0"); }
};

struct A
{
  A()
  { printf("A"); }
  virtual ~A()
  { printf("~A"); }
};

struct B : public A
{
  B() 
  {
    printf("B");
    throw 1;
  }
  ~B()
  {
    printf("~B");
  }
};


int main()
{
/* // ERROR OPTION:
  try
  {
    A0* a0 = new A0;
    A*  aa = new A;
    A*  ab = new B;
  }
  catch (...)
  {
    return 1;
  }

  // A0 A A B ~A(от B) и ВСЁ !!!
//*/

//* // SOLUTION_1
  try
  {
    std::unique_ptr<A0> a0(new A0());
    std::unique_ptr<A> aa(new A());
    std::unique_ptr<B> ab(new B());
  }
  catch (...)
  {
    return 1;
  }

  // A0 A A B ~A(от B) ~A ~A0
//*/
```

ЯВНО ЧТО-ТО Стасовское, из того, что разбирали со Стасом.

////////////////////////////////////////////////////////////
### СИНХРОНИЗАЦИЯ
```
class A;
A* p = new A();
```
можео ли применять адресную арифметику к подобному указателю ?
МОЖЕМ !

p - не объект ядра

### ЧТО ТАКОЕ ОБЪЕКТ ЯДРА ?
http://novostynauki.com/e-ntsiklopediya/lektsii/sistemnoe-programmnoe-obespechenie/yadro-operatsionnoj-sistemy-funktsii-yadra-ob-ekty-yadra-ob-ekty-yadra-na-primere-os-windows-mikroyadro/

Для работы с важными системными ресурсами ОС Windows создает объекты:
- Объекты ядра. Объект – блок памяти, выделенный ядром для своих целей и доступный только ядру.
- Объект ядра содержит имя объекта
- класс защиты объекта 
- счётчик количества пользователей и другую информацию (смещение при открытии файла и т.д.)
- Все объекты имеют описатели (Handle). Большинство объектов обладают свойством наследования.
Таблица Хэндлов.
 

- управление которыми осуществляет менеджер объектов.
(Когда приложение открывает файл, создает поток или семафор, оно получает описатель ( handle ) 
соответствующего объекта (см. рис. 4.1). Например, после выполнения программного оператора)
- Объекты ядра принадлежат ядру, а не процессу. 
- если Ваш процесс вызывает функцию, создающую объект ядра, а затем завершается, объект ядра может быть не разрушен
- если созданный Вами объект ядра используется другим процессом, ядро запретит разрушение объекта до тех пор, пока от него не откажется и тот процесс.
- Ядру известно, сколько процессов использует конкретный объект ядра, посколь ку в каждом объекте есть счетчик числа его пользователей.


### ГДЕ ХРАНЯТСЯ и НАХОДЯТСЯ Физически Уже созданные объекты ядра?
Мьютекс создали. Можем ли мы его переложить куда-нибудь ?
Обращение к ним возможно через HANDLE = Уникальный идентификатор.
Ядро возвращает нам 

Мы создали Мьютекс.
Мы работаем с Хэндлами через специальные Wait-функции и т.д.
НЕ забываем ЗАКРЫТЬ ХЭНДЛ

### Мьютекс - что это и для чего нужен.
Нужен для блокировки доступа стороннего потока к защищаемому от доступа семафором участка кода /
того участка кода как правило, внутри которго происходит обращение к какому-то общему ресурсу, который нужен Множеству потоков

Мьютексы — это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном или неотмеченном (открыт и закрыт соответственно). Когда какой-либо поток, принадлежащий любому процессу, становится владельцем объекта mutex, последний переводится в неотмеченное состояние. Если задача освобождает мьютекс, его состояние становится отмеченным.
Задача мьютекса — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. Если другому потоку будет нужен доступ к переменной, защищённой мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

Если другому потоку будет нужен доступ к переменной, защищённой мьютексом, 
то этот поток БЛОКИРУЕТСЯ до тех пор, пока мьютекс не будет освобождён.

### Как происходит "БЛОКИРОВКА" стороннего потока мьютексом ? на вечно ли ? Ставятся ли потоки в очередь ?

### Что делать, если поток заблокировал Мьютекс, началось на нём ожидание, и "забыл" выполнить его UNLOCK
или поток вообще УПАЛ (из-за ошибки / необработанного исключ.) / другой поток его прибил TerminateThread-ом ?
Что тогда будет с рассматриваемым (залоченным) Мьютексом ?

Ответ: Так как поток, в котором был создан / залочен Мьютекс перестал существовать, то и мьтекс освободится.

Верно СЛЕДУЮЩЕЕ:
- Свободном состоянии (signaled) - СИГНАЛЬНОЕ СОСТОЯНИЕ Мьютекса - Мьютекс освобождён потоком
- Занятом (not signaled) - НЕСИГНАЛЬНОЕ СОСТОЯНИЕ Мьютекса - Мьютекс залочен потоком  

### Если мы Перевели Мьютекс в НЕсигнального состояния внутри нашего потока, ТО разлочить этот мьютекс, 
тоесть перевести его в Сигнальное состояние извне (то есть из какого-либо другого потока) нельзя, это верно ?

Мьютекс - mutual exclusion - взаимное исключение

Смысл: Не допустить более одного потока к использованию какого-то ресурса (файл/переменная/сокет)


Семафоры – объекты ядра, использующиеся для учета ресурсов. Семафор имеет внутри счетчик.
Этот счетчик снизу ограничен значением 0 (семафор занят) и некоторым верхним значением N.
 В диапазоне 1..N семафор является свободным. Семафоры можно считать обобщением Mutex на несколько ресурсов


### Семейство Interlocked-функций
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Interlocked-функции не переводят процесс в режим ожидания, работают 
в пользовательском режиме, и поэтому обладают довольно большим быстродействием,
так что если необходима синхронизация для доступа к одной переменной, 
следует использовать именно их.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Используются в случае, если разным потокам необходимо изменять одну и 
ту же переменную. Например, увеличивать счетчик числа операций. 
Код вида var++; компилятором генерируется в что-то вроде
```
MOV EAX, [var]; 1
INC EAX; 2
MOV [var], EAX; 3
```

```
Соответственно, если будут два потока с таким кодом, то нельзя гарантировать,
что выполняться строки 1,2,3 первого потока, а потом 1,2,3 второго, 
первая строчка второго потока может выполнится до того, как первый запишет 
новое значение в переменную, и тогда второй поток изменит старое значение 
и перетрет изменения первого. Использование Interlocked-функций гарантирует, 
что операция будет выполнена атомарно, и описанная выше проблема отпадает.
 При использование процессоров х86 они выдают по шине аппаратный сигнал, 
 не давая другим процессорам процессорам обратится по тому же адресу памяти 
 на время работы функции.

В примере с инкрементом желанного результат можно достичь двумя функциями 
- InterlockedExchangeAdd(&var, 1), которая возвратит начальное значение var,
 либо InterlockedIncrement(&var), которая возвращает уже инкрементированое 
 значение переменной. Также существуют их 64-разрядные версии 
- InterlockedIncrement64 и InterlockedExchangeAdd64.
 
Существуют ещё функции, которые реализуют: 
- декремент: LONG InterlockedDecrement(LONG volatile *Addend), 
возвращает значение декрементированной переменной и 64-битная версия — InterlockedDecrement64
- монопольную замены текущего значения: LONG InterlockedExchange(LONG volatile *Target, LONG Value),
- логические операции: логическое «И» LONG InterlockedAnd(LONG volatile *Destination, LONG Value),
логическое «ИЛИ» InterlockedOr и сумму по модулю два InterlockedXor. 
- выполнение сравнения и присвоения как атомарной операции: 
LONG InterlockedCompareExchange(LONG volatile *Destination, LONG Exchange, LONG Comparand)

 
Большая часть синхронизации потоков связана с атомарным доступом (atomic access) 
— монопольным захватом ресурса обращающимся к нему потоком. Возьмем простой пример

// определяем глобальную переменную lorig g_x = 0;

DWORD WINAPI ThreadFunc1(PVOID pvParam) { 
g_x++; 
return(0); }

DWORD WINAPI ThreadFunc2(PVOID pvParam} { 
g_x++; 
return(0); }

Я объявил глобальную переменную g_n и инициализировал ее нулевым значением. 
Теперь представьте, что я создал два потока: один выполняет ThreadFunc1,
другой — ThreadFunc2 Код этих функций идентичен: обе увеличивают значение 
глобальной переменной g_x на 1. Поэтому Вы, наверное, подумали: когда оба 
потока завершат свою работу, значение g_x будет равно 2. 
Так ли это? Может быть. При таком коде заранее сказать, каким будет конечное 
значение g_x, нельзя. И вот почему. Допустим, компилятор сгенерировал 
для строки, увеличивающей g_x на 1, следующий код:

MOV EAX, [g_x] , значение из g_x помещается в регистр
INC EAX ; значение регистра увеличивается на 1
MOV [g_x], EAX ; значение из регистра помещается обратно в g_x

Вряд ли оба потока будут выполнять этот код в одно и то же время. 
Если они бу дут делать это по очереди — сначала один, потом другой,
тогда мы получим такую картину:

MOV EAX, [g_x] ; поток 1 в регистр помещается 0
INC EAX ; поток V значение регистра увеличивается на 1
MOV [g_x], EAX , поток 1. значение 1 помещается в g_x
MOV EAX, [g_x] ; поток 2 в регистр помещается 1
INC EAX ; поток 2. значение регистра увеличивается до 2
MOV [g_x], EAX , поток 2. значение 2 помещается в g_x

После выполнения обоих потооков значение g_x будет равно 2 
Это просто заме чательно и как раз то, что мы ожидали: 
взяв переменную с нулевым значением, дваж ды увеличили ее 
на 1 и получили в результате 2. Прекрасно. Но постойте-ка, 
ведь Windows — это среда, которая поддерживает многопоточность 
и вытесняющую мно гозадачность. Значит, процессорное время в 
любой момент может быть отнято у од ного потока и передано другому. 
Тогда код, приведенный мной выше, может выпол няться и таким образом:

MOV EAX, [g_x] ; лоток V в регистр помещается 0
INC EAX ; поток 1. значение регистра увеличивается на 1

MOV EAX, [g_x] ; поток 2 в регистр помещается 0 
INC EAX ; поток 2. значение регистра увеличивается на 1 
MOV [g_x], EAX , поток 2. значение 1 помещается в g_x

MOV [g_x], EAX , поток V значение 1 помещается в g_x

А если код будет выполняться именно так, конечное значение 
g_x окажется рав ным 1, а не 2, как мы думали! Д

```
 
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

# ПОДХОДЫ СИНХРОНИЗАЦИИ ПОТОКОВ

### 4 подхода, для организации Синхронизания потоков:

https://www.youtube.com/watch?v=MU6AeNsZ6MM


### 1) МОНИТОР - Объект умеющий в Критической Секции "Приотпускать" замок.
Чтобы после наступления какого-то события (await for condition)
возобносить свою работу (конкурируют за замок на общих началах)
ПРИМЕР: поток deque(), ждёт пока в очереди не появится элемент.
Проблема мониторов Lost wake-up - ненаступление условия - лечится установкой timeout-ов.

### 2) Read-Write Locks - замки устанавливающие уровень доступа к данным.
Возможен захват Reader-замка несколькими потоками.
НЕВОЗМОЖЕН при захваченом Writer-замке.
Пример: SELECT/UPDATE в БД, Доступ к файлу.

### 3) Reentrant lock - замок, который можно повторно захватить, 
если он уже принадлежит исполняющемуся потоку.

### 4) СЕМАФОР - примитив пускающий в "критическую секцию", не более N потоков.
Пример: Распределение ограниченного числа (счтёных) ресурсов 
- сокетов, ядер, IO-операций, подключений к БД, лицензий. 


### (1) Пример: наш объект заблокирован потоком, но этот поток должен 
выполнить какую-то операцию, для которой у него не хватает ресурсов.
К примеру_1 - в него есть вложенная блокировка. Он захватил объект_1, 
и после этого же он хочет захватиь объект_2, но объект_2 для него недосупен.
К примеру_2 - Он захватил объект_1, и он дожидается определённого времени, 
для того, чтобы исполнить свои действия, и не даёт другим в дуоступ объект_1.
Если он будет просто ждать - это неэффективно

Было бы эффективнее, если бы ПОКА наш поток ожидает освобождения объекта_2,
он бы отпустил временно объект_1.

### МОНИТОР - отпускает замок над нашим объектом, до наступления какого-то события.
Монитору должно быть чётко поисано само событие.
Пример МОНИТОРА в жизни - Поток ждёт Момент, когда надо взять элемент из очереди. 
В случае, если в очереди Элементов НЕТ, он будет ждать очень долго,
а очеред при этом будет удерживаться. Но мы можем и ДОЛЖНЫ дать другому потоку
возможность дать отпущеную очередь, чтобы он положил в неё элемент.
МИНУСЫ МОНИТОРОВ - Проблема Пропущенного события - Монитор пропустил событие,
по которому он должен проснуться, потомучто оно наступило, и монитор этого не заметил.
Решение тут - выставлять таймеры на процесс ожидания/СНА, чтобы он Подержал объект, 
отпустил его ушёл спать, и если событие которого он ожидает так и не наступило, 
в течение 30 секунд, он просыпается автоматически и пытается сново получить доступ к объекту.

### (2) Если мы открываем файл на ЧТЕНИЕ, то это не мешает открыть и ЧИТАТЬ файл кому-то другому.
У них имеется РАЗНЫЙ УРОВЕНЬ доступа к данным, т.е. замок может 2 Уровня
- Захват объекта на ЧТЕНИЕ - Он НЕ МЕШАЕТ другим потокам так же захватывать это объект на чтение
	НО, тогда он заблокирован на ЗАПИСЬ и изменение такого объекта
- захват объект на ЗАПИСЬ - будет доступен другим потокам и на чтение и на запись.

ПРИМЕР: Запросы в БД SELECT / UPDATE:
  SELECT может быть множественным, и не блокирует табоицу.
  UPDATE - сначала будет исполнено изменение, а потом передатся управление для SELECT-a

### (3) Дважды залочить один и тот же замок. Используем чужой код, и в нашей внешней части кода нам
  нужно заблокировать что-то, что находится и заблокированно ещё и внтури.
	
### (4) Семафор это организующий примитив, который позволяет некоторому колчиеству потоков ожновреиенно 
  заходить в критическую секцию, но не более чем обозначенному количеству.

Система БД, которая способна обеспечить по лицензии не более чем 5 подключений.
Мы делаем ПУЛ подключений, ограничиваем этот Пул Семафором, 
и использовать то число подключений / потоков,
солько нужно, согласно ограничению

МЬЮТЕКС:
- Крупнозернистая синхронизация.	

	
АБСТРАКТНЫЕ ЗАДАЧИ МНОГОПОТОЧНОСТИ / СИНХРОНИЗАЦИИ:
- Обедающие философы	
- Дилемма заключённого
- Людоед и шапки 2-ух цветов

### 1) Критические Секции
### 2) Мьютексы
### 3) События
### 4) Семафоры
### 5) Lock Free
### 6) InterLocked функции



# BO QUAN

```
Многопроцессность:	
процесс_1 <-> Межпроцессное взаимодействие (каналы) <-> процесс_2
файлы, пайпы, сообщения

Многопоточность:
поток_1 <-> разделяемая память <-> поток_2

+Многопоточность - поток проще и быстрее запустить
    Чтобы запустить процесс, ОС необходимо выделить 
    под него гораздо больше ресурсов.
    Процессу нужно больше безоаснсоти, чтобы они 
    не наступали друг на друга в ОС 
    (процессы же работают через посредников)

    Потоки же существуя в рамках процессов живут 
    более раздельно друг от друга (встречаясь и 
    работая только с разделяемой памятью/ресурсами)

Межпотоковое взаимодействие сильно 
более быстрое, чем Межпроцессное

						
Треды:
  Джойн.
  Можно проверить джоинабл он или нет

////////////////////////////////////////////////////////////
THIS_THREAD

std::this_thread::sleep_for(chrono::second(1));
Всегда позволяет нам узнать НАШ поток, или выполнить именно в ТЕКУЩЕМ потоке что-то
	
////////////////////////////////////////////////////////////
JOIN

В этом примере, thr — это объект, представляющий поток, в котором будет выполняться функция threadFunction().
join() -  блокирует вызывающий поток (в нашем случае — поток main) до тех пор, пока thr 
(а точнее threadFunction()) не выполнит свою работу. Если функция потока возвращает значение 
— оно будет проигнорировано. Однако принять функция может любое количество параметров.
						

////////////////////////////////////////////////////////////
  ПРОБЛЕМЫ СИНХРОНИЗАЦИИ:
- Гонки (Data Race)
- Взаимные блокировки (DeadLock)

////////////////////////////////////////////////////////////
						
Параметры в функцию потока всегда передаются по значению (копия объекта), а не по ссылке.
Чтобы передача происходила по ссылке нужно:

fun(string& msg) {}

main
{
  string s = "1";
  thread t1(fun, ref(s)); 
  thread t1(fun, move(s)); // второй вариант передачи параметра в поток 
}

thread tr2 = tr1; // ERROR will NOT work
tr2 = move(tr1); // перенесём содержимое потока в поток tr2
 
////////////////////////////////////////////////////////////

Гонки ... 

Мы можем разграничить доступ к общему используемому 
ресурсу в нашем случае это cout::  стандартнй вывод:

////////////////////////////////////////////////////////////
обычный мьютекс:
mutex mu;

МНОЖЕСТВО ПОТОКОВ Обращаются именно к этой функции и к общему для всех обхекту  cout
fun(int i)
{
	mu.lock();
	cout << i;
	mu.umlock();
}

лок - один поток
один поток сделал своё дело
анлок - один поток

и сразу после
лок - второй поток
второй поток сделал своё дело
анлок - второй поток

и так каждый поток гарантированно, не задев объект синхронизации одноврмеенно.
или в нужной, прогеру последовательности

////////////////////////////////////////////////////////////
mutex mu;
lock_guard<mutex> guard(mu);

lock_guard - Реализует RAII:
Автоматически выполнит лок и анлок в рамках заданной единицы трансляции
fun()
{ // начало блока
  lock_guard<mutex> guard(mu); // от момента инициализации, до конца  БЛОКА  функции
} // конец блока

// это работает, только если множество потоков будет вызывать именно эту 

////////////////////////////////////////////////////////////
ПРОБЛЕМА.
любой другой поток, тоесть новая функция которую мы введём и которая будет юзать  cout
и если в ней не будет того же самого мутекса с лок/анлок или мутекс_гуарда с этим мутексом, то Ж 

Тогда просто создаём класс, с мьютексом, лочим функцию которую будем шарить между потоками
с использованием лок-гарда и используем объект класса в потоках по ссылке, и в основном потоке просто инстанс.

Никогда не должен возвращаться сам объект, разделяемый между потоками.


```

# ДЕДЛОК - взаимная блокировка

```
mutex m_1
mutex m_2

fun_1()
{
  lock_guard<mutex> locker(m_1);
  lock_guard<mutex> locker2(m_2);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

fun_2()
{
  lock_guard<mutex> locker2(m_2);
  lock_guard<mutex> locker(m_1);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

Синхронно выполняем обе функции:
1 шаг - 1поток в fun - lock_guard<mutex> locker (m_1); залочили m_1
2 шаг - 2поток - lock_guard<mutex> locker2(m_2); залочили m_2
3 шаг - 1поток - lock_guard<mutex> locker2 (m_2); ХОЧЕТ ЗАЛОЧИТЬ m_2, Но он уже залочен в первой строчке второй функции во втором потоке
4 шаг - 2поток - lock_guard<mutex> locker1 (m_1); ХОЧЕТ ЗАЛОЧИТЬ m_1, Но он уже залочен в первой строчке первой функции в  первом потоке
ДЕДЛОК !

РЕШЕНИЕ_0:
Использовать по ОДНОМУ локу анлоку в ОДНОЙ области видмости

fun_1()
{
	part_1
	{
		lock_guard<mutex> locker(m_1);
		// защищаемый объект_1 1-ым мьютексом
	}
	part_2
	{
		lock_guard<mutex> locker2(m_2);
		// защищаемый объект_2 2-ым мьютексом
	}
}

fun_2()
{
  lock_guard<mutex> locker(m_1);
  lock_guard<mutex> locker2(m_2);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

РЕШЕНИЕ_1:
Лочить мьютексы ПОСЛЕДОВАТЕЛЬНО, в каждой из функций в ОДИНАКОВОЙ последоваткельности

fun_1()
{
  lock_guard<mutex> locker(m_1);
  lock_guard<mutex> locker2(m_2);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

fun_2()
{
  lock_guard<mutex> locker(m_1);
  lock_guard<mutex> locker2(m_2);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

РЕШЕНИЕ_2 STL:

fun_1()
{
  std::lock(m_1, m2);
  lock_guard<mutex> locker(m_1, std::adopt_lock);  // adopt_lock - говорит locker-у,
                    // что мьютекс m_1 уже залочен, так что достаточно просто 
  lock_guard<mutex> locker2(m_2, std::adopt_lock);  // "получить владение"
                    // этим мьютексом, чтобы удалить его как выйдем за пределы области
		    // видимости (out of scope), надо просто не забыть освободить мутекс
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

fun_2()
{
  lock_guard<mutex> locker(m_1);
  lock_guard<mutex> locker2(m_2);
  // защищаемый объект_1 1-ым мьютексом
  // защищаемый объект_2 2-ым мьютексом
}

НЮАНС:
- стоит избегать вызова функцции определённой пользователем
на том промежутке кода, где вы используете lock_guard<mutex>

fun()
{
	lock_guard<mutex> locker(m);
	user_function();
}

- задать приоритетность мьютексам.
Чтобы пока поток залочил низкоуровневый мьютекс, он не может залочить Высокоуровневый мьютекс

- С защитой объектов от захвата нужно поступать очень аккуратно и с ВЫСОКОЙ ГРАНУЛЯРНОСТЬЮ
"Хороший" Лок - лочит маленький участок кода. Однако это может породить дедлоки
"Плохой" - большие участки кода от исполнения. Однако треды могут долго ждать освобождения ресурсов
"Золотая середина" - которой нет ...



////////////////////////////////////////////////////////////

https://habrahabr.ru/post/182610/

- lock_guard: когда объект создан, он пытается получить мьютекс (вызывая lock()), 
	а когда объект уничтожен, он автоматически освобождает мьютекс (вызывая unlock())

- unique_lock: в отличие от lock_guard, также поддерживает отложенную блокировку,
	временную блокировку, рекурсивную блокировку и использование условных переменных	


Конструкторы классов «оберток» могут принимать параметр, определяющий политику блокировки:
- defer_lock типа defer_lock_t: не получать мьютекс
- try_to_lock типа try_to_lock_t: попытаться получить мьютекс без блокировки
- adopt_lock типа adopt_lock_t: предполагается, что у вызывающего потока уже есть мьютекс

Для решения этой проблемы можно использовать 
- std::lock, который гарантирует блокировку безопасным (с точки зрения взаимоблокировки) способом:

     std::lock(c1._lock, c2._lock); 
     c1.remove(value);
     c2.add(value);
     c1._lock.unlock();
     c2._lock.unlock();

- lock: блокирует мьютекс, используя алгоритм избегания deadlock'ов (используя lock(), try_lock() и unlock())
- try_lock: пытается блокировать мьютексы в порядке, в котором они были указаны	 

```

# ЮНИКЛОК - взаимная блокировка

```

1) позволяет сделать отложенную РАЗблокировку:
void shared_print()
{
	unique_lock<mutex> locker(m);
	// то, что требует синхронизации через мьютекс m
	locker.unlock(); // позволяет сделать это раньше, чем конец области видимости
	// от этого момента нам залоченный мьютекс не нужен
}

2.1) Можно создать объект locker, но при этом НЕ ЗАЛОЧИТЬ мьютекс
     Реализует механизм "ОТЛОЖЕННАЯ БЛОКИРОВКА"
2.2) МНОЖЕСТВО РАЗ делать ЛОК / АЛОК в рамках одной области видимости / одного блока { }
	 lock_guard так не умеет
2.3) Может  std::move() - быть ПЕРЕМЕЩЁН - функцией ПЕРЕМЕЩЕНИЯ, и при перемещении
     ВЛАДЕНИЕ Мьютексом переходит от одного unique_lock_1 к unique_lock_2
	 std::unique_lock<mutex> locker_1(mutex);
	 ...
	 std::unique_lock<mutex> locker_2 = std::move(locker_1);
	 
НЮАНС - Он БОЛЕЕ ТЯЖЁЛЫЙ, чем lock_guard (который более ЛЕГКОВЕСНЫЙ) 
	 
void shared_print()
{
	unique_lock<mutex> locker(m, std::defer_lock); // m - будет
	            // не залочен при создании locker. его нужно будет залочить вручную
	//сначала делаем то, что не требует синхронизации
	locker.lock(); // 1-ЫЙ РАЗ
	// то, что требует синхронизации через мьютекс m
	locker.unlock(); // позволяет сделать это раньше, чем конец области видимости

	// от этого момента нам залоченный мьютекс не нужен
	locker.lock(); // 2-ОЙ РАЗ
	// то, что требует ПОВТОРНОЙ синхронизации через мьютекс m
	locker.unlock();	
}

////////////////////////////////////////////////////////////
ЛЕНИВАЯ ИНИЦИАЛИЗАЦИЯ
Отложенная инициализация
lazy initialisation

class LogFile
{
	std::mutex m_mtx;
	std::ofstream m_f;
public:
	LogFile()
	{
		m_f.open("file.txt");
	}
	
	void shared_print(std::string _s)
	{
		unique_lock<mutex> locker(m_mtx);
		m_f << "PRINT: " << _s << std::endl;
	}
};

Тут в конструкторе мы открываем файл.
НО Что если в коде, разраб, пользующийся
нашим классом никогда не вызовет shared_print
И зачем нам тогда открытый файл вприцнципе ?

Для этого Инициализируем и откроем Файл ТОЛЬКО
внутри самой функци, единожды, кода она вызовется

class LogFile
{
  std::mutex m_mtx;
  std::ofstream m_f;
public:
  LogFile() { }
  
  void shared_print(std::string _s)
  {
    if(!m_f.is_open())	      // Lazy initialisation
    { m_f.open("file.txt"); } // ИДЕОМА - инициализация до первого использования

    unique_lock<mutex> locker(m_mtx);
    m_f << "PRINT: " << _s << std::endl;
  }
};

////////////////////////////////////////////////////////////
ПОТОКО  НЕ  БЕЗОПАСНЫЙ КОД

class LogFile
{
  std::mutex m_mtx_1;
  std::mutex m_mtx_2;
  std::ofstream m_f;
public:
  LogFile() { }
  
  void shared_print(std::string _s)
  {
    if(!f.is_open()) {			    // cтр.1
    unique_lock<mutex> locker_2(m_mtx_2); // cтр.2
      m_f.open("file.txt");		    // cтр.3
    }
    					    // cтр.4
    unique_lock<mutex> locker_1(m_mtx_1);
    m_f << "PRINT: " << _s << std::endl;
  }
};

НЕБЕЗОПАСНОСТЬ: Имеем 2 потока (В рамках 1 шага 2 потока могут выполнить параллельно по одной операции в рамках одной строки):
-- шаг 1
поток 1 (стр.1): зашёл, увидел, что файл НЕ открыт, заходит в функ.
-- шаг 2
поток 1 (стр.2): лочит мьютекс, собирается перейти к строчке 3 и открыть файл
поток 2 (стр.1): зашёл, увидел, что файл ЕЩЁ НЕ открыт (поток 1 в это же время только залочил мьютекс, но ещё не перешёл на строчку 3)
-- шаг 3
поток 1 (стр.3): открывает файл		-- ФАЙЛ ОТКРЫТ (в потоке 1) --
поток 2 (стр.2): лочит мьютекс
-- шаг 4
поток 1 (стр.3): выходит из функции
поток 2 (стр.2): открывает файл		-- ФАЙЛ ОТКРЫТ (в потоке 2) --
--- РЕЗУЛЬТАТ: Файл одновременно открыт в Двух потоках.... Плохо просинхронизировали ....


// РЕШЕНИЕ  НЕправильное:

class LogFile
{
  std::mutex m_mtx_1;
  std::mutex m_mtx_2;
  std::ofstream m_f;
public:
  LogFile() { }
  
  void shared_print(std::string _s)
  {
    {
    unique_lock<mutex> locker_2(m_mtx_2);	// cтр.1
      if(!f.is_open()) 				// cтр.2
      { m_f.open("file.txt"); }			// cтр.3
    }
    						// cтр.4
    unique_lock<mutex> locker_1(m_mtx_1);
    m_f << "PRINT: " << _s << std::endl;
  }
};
	
ТАКОЕ решение плохое, ибо оно требует захвата мутекса КАЖДЫЙ РАЗ,
в каком-то смысле теряется как таковая "многопоточность" +нагрузка процессора и потеря процессорного времени
ПРИ том, что файл нам вообще говоря нужно открыть ЕДИНОЖДЫ


////////////////////////////////////////////////////////////
// РЕШЕНИЕ  ПРАВИЛЬНОЕ:

- ЕСЛИ нужно сделать что-то ЕДИНОЖДЫ в одном из потоков

ONCE_FLAG - позволяет чему-то выполниться в одном из потоков ЕДИНОЖДЫ

class LogFile
{
  std::mutex m_mtx_1;
  std::once_flag flag;
  std::ofstream m_f;
public:
  LogFile() { }
  
  void shared_print(std::string _s)
  {
    call_once(_flag, [&]() { m_f.open("log.txt"); }); // Файл 
                    //будет открыть ЕДИНОЖДЫ Одним из потоков
    unique_lock<mutex> locker_1(m_mtx_1);
    m_f << "PRINT: " << _s << std::endl;
  }
};



////////////////////////////////////////////////////////////
// Condition Variable - УСЛОВНЫЕ ПЕРЕМЕННЫЕ

std::deque<int> q; // доступ к очереди - ГОНКИ потоков! (кто быстрее запихнёт/удалит)
std::mutex mu;

void fun_1() // producer
{
  int count =10;
  while(count > 0)
  {
  unique_lock<mutex> locker(mu);
    q.push_front(count);
    locker.unlock();
    sleep_for(chrono::seconds(1));
    count--;
  }
}

void fun_2() // consumer
{
  int data = 0;
  while(data != 1)
  {
  unique_lock<mutex> locker(mu);
    if(! q.empty())
    {
      data = q.back();
      q.pop_back();
      locker.unlock();  // UNLOCK_1
      cout << "DATA:" << data << endl;
    }
    else
    {
      locker.unlock(); // UNLOCK_2
    }
  }
}

int main()
{
  thread t_1(fun_1);
  thread t_2(fun_2);
  t_1.join();
  t_2.join();
  // ожидаем в основном потоке завершение двух созданных потоков
  return 1;
}

FUN_2  исполняет BUSY WAITING 
- Ожидание ВХОЛОСТУЮ или - ПРОСТОЙ 
- многократный непрерывный заход в цикл while() loop
Происходит МНОГОКРЫТНЫЙ выхов РАЗБЛОКИРОВКИ в fun_2, 
так как разблокировка за пределами цикла

// РЕШЕНИЕ Плохое:

void fun_2() // consumer
{
...
  else
  {
    std::this_thread::sleep_for(chrono::second(1));
    locker.unlock();
  }
}

НЮАНС:  Да мы СОКРАТИМ число заходов в Цикл на единицу времени
  НО: Как как понять СКОЛЬКО нужно спать потоку ?
    1. если выставим слишком мало  - поток будет входить в цикл слишком часто и Ожидать вхолостую
    2. если выставим слишком много - Мы можем таки НЕ получить данные во время

////////////////////////////////////////
// РЕШЕНИЕ ПРАВИЛЬНОЕ:

std::deque<int> q; // доступ к очереди - ГОНКИ потоков! (кто быстрее запихнёт/удалит)
std::mutex mu;
std::condition_variable cond;

void fun_1() // producer
{
  int count =10;
  while(count > 0)
  {
    unique_lock<mutex> locker(mu);
	q.push_front(count);
	locker.unlock();
	cond.notify_one(); // Оповестить один ждущий поток, 
	     //если есть таковой, с данной Условной переменой cond
	     //cond.notify_all(); // Разбудит ВСЕ потоки, 
	                          //что ждут на данной условной переменной.
	sleep_for(chrono::seconds(1));
	count--;
  }
}

void fun_2() // consumer
{
  int data = 0;
  while(data != 1)
  {
    unique_lock<mutex> locker(mu);
	cond.wait(locker); // Дойдёт до сюда 
	// и будет ждать, пока у данной переменной 
	// в другом потоке не будет выствлен 
	// ОПОВЕЩАЮЩИЙ ФЛАГ через метод notify_one
	// и ждать она будет того, чтобы залочить соответсвенно мьютекс
	
	  data = q.back();
	  q.pop_back();
	  locker.unlock();
	  cout << "DATA:" << data << endl;
  }
}

int main()
{
  thread t_1(fun_1);
  thread t_2(fun_2);
  t_1.join();
  t_2.join();
  // ожидаем в основном потоке завершение двух созданных потоков
  return 1;
}

ВЫВОД: С помощью Условных переменных мы можем Управлять 
последовательностью остановки и возобновления потоков,
и реализовывать ОТЛОЖЕННЫЙ Запуск и Возобновление потока, определяемый нами.

НЮАНС: Почему cond.wait(locker);  wait-функции нужен locker в качесве параметра
  на предыдущем шаге мьютекс захвачивается потоком_2
  и поток не должен ожидать "засыпать" при удержании мьютекса, ибо
  зачем задерживать мьютекс, когда ты собираешся заснуть (ведь если заснёшь .... 
  то когда и как освободишь его ... не понятно)
  На время Засыпания потока нам не хочется блокать всех остальных, кто может поспользоваться мьютексом
ИТАК перед wait-функцией мы посылаем поток_2 в СПЯЧКУ и это сделает НЕЯВНЫЙ UNLOCK locker-a, 
  который передаётся в wait-функцию и только после этого 
  поток_2 отправится в СПЯЧКУ.
ААА КАК ТОЛЬКО поток_2 будет РАЗБУЖЕН через вызов функции notify_one(), 
  это ЗАЛОЧИТ locker обратно, и только после этого 
  в рамках потока_1 мы сможем МНОПОЛЬНО владеть ресурсом  q  ,
  и после чего дойдя до locker.unlock(); мы и разлочим залоченый locker.
Так как в данной ситуации надо много много раз вызывать lock() / unlock(),
 то тут нам ЯВНО нужен именно unique_lock,
 в комбинации с condition_variable

////////////////////////////////////////////////////////////
// Condition Variable
// ФОРСМАЖОРНОЕ_ПРОСЫПАНИЕ (САМОПРОСЫПАНИЕ) из режима wait-функции - SPURIOUS WAKE.

Суть: Запустили wait(), поток заснул, есть 2 варианта ПРОСНУТЬСЯ:
(1) condition_variable вызовет  notify_one()
(2) поток может проснуться САМОСОТОЯТЕЛЬНО (spurious wake)

(2) В случае  spurious wake  может возникнуть ситуация, 
КОГДА поток проснулся не по нашему желанию / незапланированно / ФОРСМАЖОРНОЕ_ПРОСЫПАНИЕ ,
в этом случае, мы хотим избежать неопределённого поведения или ошибки, 
или проблем с логикой, которую вызвало ПРОСЫПАНИЕ потока

ЕСЛИ мы не хотим, чтобы поток проснулся и продолжил своё выполнение, 
 мы можем отправить его ОБРАТНО В СОН (СПАТЬ - ибо нефиг было просыпаться)

 Чтобы избежать неконтролируемого ПРОСЫПАНИЯ ПОТОКА "Не при тех условиях и не в то время", 
МОЖНО В качестве дополнительной Функции-предиката, функция, проверяющая УВСЛОВИЕ, 
передавать таковую в качестве ВТОРОГО ПАРАМЕТРА в ф-цию wait(mutex, PREDICATE_FUNC())
		
cond.wait(locker, [](){ return !q.empty();} );
		
Лямбда-функция [](){ return !q.empty();} - будет возвращать успех, если  q  НЕпусто
Следовательно: Если поток_2 проснулся, то ТЕПЕРЬ о посмотрит на результат выполнения функции-предиката.
 predicate_fun() == FALSE - и поток уйдёт СПАТЬ дальше
 predicate_fun() == TRUE  - и поток ПРОСНЁТСЯ и продолжит исполнение кода
		
////////////////////////////////////////////////////////////
// Condition Variable
// МНОГО потоков ожидающих на ОДНОЙ УСЛОВНОЙ Переменной

  cond.notify_one(); - Разбудит ТОЛЬКО ОДИН единственный поток.
  
  cond.notify_all(); - Разбудит ВСЕ потоки, что ждут на данной условной переменной.
		

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
// Furure  +  Promise  +  async()

#include <future>

using namespace std;

void factoreal(int N)
{
  int res = 1;
  for (int i = N; i > 1; i--)
  {
    res *= i;
  }

  cout << "Result is: " << res << endl
}

int main()
{
  std::thread t1(factoreal, 4);

  t1.join();
  return 0;
}

```


# F2FA1C23-2E60-4135-91D3-193007215549

### Q: Шпаргалка по QT !

http://cppstudio.com/post/11167/

### Q: Как работают события в c++ ?

https://habr.com/ru/post/424593/

### Q: Что такое QEvent QT ?

// TO DO

### Q: Как отловить / получить Event из какого-то объекта или внутри определённого объекта в QT ?

https://www.opennet.ru/docs/RUS/qt3_prog/x3974.html

В Qt предусмотрены **ПЯТЬ** уровней, на которых событие может быть перехвачено и обработано:

1. **Обработка событий в функциях-обработчиках**

Перекрытие обработчиков событий, таких как: mousePressEvent(), keyPressEvent() и paintEvent(), безусловно самый распространенный способ. Мы уже видели множество примеров тому.

2. **Перекрытие метода QObject::event()**

Внутри этого обработчика мы можем перехватывать события до того, как они попадут в специализированные функции-обработчики. Этот подход чаще всего используется для того, чтобы изменить реакцию виджета на клавишу табуляции, как это было показано ранее. Он так же используется для обработки событий, которые встречаются не так часто, например: LayoutDirectionChange. Если мы перекрываем функцию event(), то необходимо предусмотреть вызов обработчика event() базового класса, чтобы обработать события, которые нас не интересуют.

3. **Установка фильтра событий для QObject**

После того, как фильтр будет зарегистрирован функцией installEventFilter(), все события, предназначающиеся указанному объекту, сначала будут попадать в обработчик eventFilter(). Такой способ мы использовали для перехвата событий от клавиши "пробел" в примере выше.

4. **Установка фильтра событий объекта QApplication**

После регистрации фильтра, любое событие, предназначенное для любого объекта в приложении, будет сначала попадать в обработчик eventFilter(). Такой подход чаще всего используется в целях отладки и реализации в приложении скрытых сюрпризов (так называемых "пасхальных яиц").

5. **Создание дочернего класса от QApplication и перекрытие метода notify()**

Qt вызывает QApplication::notify(), чтобы передать событие приложению. Таким способом можно перехватить любое событие до того, как оно попадет в фильтр событий. Вообще фильтры событий более удобны, поскольку допускается одновременное существование любого количества фильтров, а функция notify() может быть только одна.

- ** Event Handlers **

The normal way for an event to be delivered is by calling a virtual function.
For example, QPaintEvent is delivered by calling QWidget::paintEvent().
For example, the following code handles left mouse button clicks on a custom checkbox widget while passing all other button clicks to the base QCheckBox class:
```
keyPressEvent(QKeyEvent *event) 
mouse release
mouseMoveEvent
void MyCheckBox::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        // handle left mouse button here
    } else {
        // pass on other buttons to base class
        QCheckBox::mousePressEvent(event);
    }
}

bool MyWidget::event(QEvent *event)
{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent *ke = static_cast<QKeyEvent *>(event);
        if (ke->key() == Qt::Key_Tab) {
            // special tab handling here
            return true;
        }
    } else if (event->type() == MyCustomEventType) {
        MyCustomEvent *myEvent = static_cast<MyCustomEvent *>(event);
        // custom event handling here
        return true;
    }

    return QWidget::event(event);
}
```

- **Event Filters**

Sometimes an object needs to look at, and possibly intercept, the events that are delivered to another object. For example, dialogs commonly want to filter key presses for some widgets; for example, to modify Return-key handling.
```
bool FilterObject::eventFilter(QObject *object, QEvent *event)
{
    if (object == target && event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
        if (keyEvent->key() == Qt::Key_Tab) {
            // Special tab handling
            return true;
        } else
            return false;
    }
    return false;
}
```

- Sending Events
```
sendEvent() processes the event immediately. When it returns, the event filters and/or the object itself have already processed the event. For many event classes there is a function called isAccepted() that tells you whether the event was accepted or rejected by the last handler that was called.
postEvent() posts the event on a queue for later dispatch.
```

### Q: Разница между sendEvent() и postEvent() ?

- sendEvent() - обрабатывает событие срезу, в обход очереди сообщений И она возвращает значение и фильтр или объект к этому времени уже обработали его. У некоторых классов есть isAccepted() был ли евент принят или отклонён обработчиком событий.
- postEvent() - ставит событие в очередь сообщений для последующей обработки.

### Q: Как работают события в QT ?

// TO DO



### Q: Что такое сигнал ?

Сигналы являются публично доступными функциями и могут быть вызваны где угодно, но рекомендуется их вызывать только в классе, где они были определены, а также в его подклассах
Сигналы автоматически генерируются в moc и не должны быть определены в .cpp файле, а также они никогда не возвращают результат.

### Q: 
1. случай - 2 объекта находятся в одном потоке и происходит у них сигнал 
2. случай - 2 объекта находятся в разных потоках и происходит у них сигнал 
Будет ли какаято разница ?
```
Соединение происходит. Но слот никогда не сработает. Объясню почему. 

QObject::connect(server,SIGNAL(runIt(int)),func,SLOT(run(int))); 
этот метод, кроме этих четырёх параметров имеет и пятой параметр по умолчанию.
Он задаёт тип соединения.
Qt поддерживает 4 типа signal-slot connection-ов типов соединений:
1) Auto Connection (default) - If the signal is emitted in the thread which the receiving object has affinity then the behavior is the same as the Direct Connection. Otherwise, the behavior is the same as the Queued Connection."
2) Direct Connection - The slot is invoked immediately, when the signal is emitted. The slot is executed in the emitter's thread, which is not necessarily the receiver's thread.
3) Queued Connection - The slot is invoked when control returns to the event loop of the receiver's thread. The slot is executed in the receiver's thread. Blocking Queued Connection The slot is invoked as for the Queued Connection, except the current thread blocks until the slot returns. Note: Using this type to connect objects in the same thread will cause deadlock.
4) Unique Connection - The behavior is the same as the Auto Connection, but the connection is made only if it does not duplicate an existing connection. i.e., if the same signal is already connected to the same slot for the same pair of objects, then the connection is not made and connect() returns false.

По умолчанию сотит AutoConnection. Что это означает?
Если у вас два соединённых объекта находятся 
В ОДНОМ и том же потоке, то слот будет вызываться сразу же,
когда будет имитирован сигнал.

Но когда Ваши объекты находятся 
В РАЗНЫХ потоках, имитированные сигналы не будут вызывать слот сразу,
они будут помещены в цикл событий потока, и будут исполнены,
когда придёт их очередь, т.е. сигнал не сможет быть доставлен
(слот не сможет быть вызван), пока не закончится выполнение той функции,
в которой был имитирован сигнал.

У Вас бесконечный цикл, поэтому и все Ваши сигналы на очереди исполнения.
Остановите Вашу функции)) и удивитесь, сколько же раз будет вызван слот ;)

В Вашем случае, решение проблемы, это указать в connect пятым аргументом DirectConnection.
Но это не рекомендуется делать по документации qt, потому что это не безопасно,
если объекты находятся в разных потоках. Всё, что я сказал, есть в док.
```

1) Создаю объект со слотом run() в основном потоке (прямо в main()):
```
Function* func = new Function;
```
2) Запускаю асинхронно serverThreadGlobal:
```
QFuture<int> future = QtConcurrent::run(serverThreadGlobal,func);
```
3) Внутри функции создаю объект класса с сигналом runIt и соединяю сигнал и слот:
```
int serverThreadGlobal(Function* func)
{
    std::cout<<"serverThreadGlobal\n";
    Server* server = new Server;
    QObject::connect(server,SIGNAL(runIt(int)),func,SLOT(run(int)));
//тут испускается сигнлал emit runIt(0);
    server->serverCycle(func);
    return 1;
}
```
4) Не соединяет! (слот void Function::run(int n) не срабатывает)
```
Код функции serverCycle

void Server::serverCycle(Function* func)
{
    emit runIt(0);
    while(1)
    {
        Sleep(1000);
        emit runIt(0);
        std::cout<<"working\n";
    }
}
```

### Q: Варианты взаимодействия между С++ и QML ?

1. Макрос Q_PROPERTY в бекенде С++ класса (val, get, set, sig valChanged)
2. Макрос Q_INVOKABLE в бекенде С++ класса (Q_INVOKABLE-метод)
3. Общение через Сигналы заведённые на стороне C++
4. Общение через Сигналы заведённые на стороне QML
5. QQmlProperty::read(object, "someNumber").toInt();
6. QMetaObject::invokeMethod(...)
7. QQuickView view(QUrl::fromLocalFile("MyItem.qml")); QObject *item = view.rootObject();

1. Макрос Q_PROPERTY в бекенде С++ класса

- позволяет задать переменную на стороне плюсов и qml. Оба слоя одинаково имеют к ней доступ.
- с++ может сделать set через set метод, qml и cpp получить через get метод 
- этот макрос так же определяет сигнал  somePropertyChanged, чтобы сpp-сторона информировала qml об изменении переменной
- на стороне qml моно добавить соотвествующий обработчик onSomePropertyChanged: { } чтобы отловить событие об изменении
```
class BackEnd : public QObject { Q_OBJECT
    Q_PROPERTY(QString userName READ userName WRITE setUserName NOTIFY userNameChanged)
public: int   getSomeProperty() const;
        void  setSomeProperty(const int &);
private: int  someProperty;
signals: void somePropertyChanged();
...
```

```
#include "backend.h"
int main(int argc, char *argv[])
{
  qmlRegisterType<BackEnd>("io.qt.examples.backend", 1, 0, "BackEnd");
...
```

```
import io.qt.examples.backend 1.0

ApplicationWindow { id: root
  BackEnd {
    id: backend
    someProperty: 10
    omSomePropertyChanged: {
      // наш код
    }
  }
...
```

2. Макрос Q_INVOKABLE в бекенде С++ класса
позволит вызывать Q_INVOKABLE-метод как метод qml объекта
```
class TestClass : public QObject
{
    Q_OBJECT
public:
    Q_INVOKABLE
    void myMethod();
};
void TestClass::myMethod() { qDebug() << "!"; }
```

```
import ModuleName 1.0
TypeName{
 id: myObj
  someProperty: 10
  }

 Rectangle{
  MouseArea {
   onClicked: {
    myObj.myMethod();
 }}}

```


3. Общение через Сигналы заведённые на стороне C++
```
class TestClass : public QObject
{
    Q_OBJECT
signals:
    void someSignal();
};
...
void TestClass::mySlot()
{
    emit someSignal();
}
```

```
TypeName
{
  id: myObj
  onSomeSignal: {
    Qt.quit();
  }
} 
```

4. Общение через Сигналы заведённые на стороне QML
```
Item { 
    signal qmlSignal(msg: string)
...
```

```
class MyClass : public QObject
{
    Q_OBJECT
public slots:
    void cppSlot(const QString &msg) {
        qDebug() << "Called the C++ slot with message:" << msg;
    }
};
```

```
int main(int argc, char *argv[]) {
    QGuiApplication app(argc, argv);

    QQuickView view(QUrl::fromLocalFile("MyItem.qml"));
    QObject *item = view.rootObject();

    MyClass myClass;
    QObject::connect(item, SIGNAL(qmlSignal(QString)),
                     &myClass, SLOT(cppSlot(QString)));
...
```

5. QQmlProperty::read(object, "someNumber").toInt();
```
// MyItem.qml
import QtQuick 2.0
Item { property int someNumber: 100; }
```
The value of the someNumber property can be set and read using QQmlProperty, or QObject::setProperty() and QObject::property():
```
QQmlEngine engine;
QQmlComponent component(&engine, "MyItem.qml");
QObject *object = component.create();
qDebug() << "Property value:" << QQmlProperty::read(object, "someNumber").toInt();
QQmlProperty::write(object, "someNumber", 5000);
qDebug() << "Property value:" << object->property("someNumber").toInt();
object->setProperty("someNumber", 100);
```

6. QMetaObject::invokeMethod(object, "myQmlFunction", Q_RETURN_ARG(QString, returnedValue), Q_ARG(QString, msg));
```
import QtQuick 2.0

Item {
    function myQmlFunction(msg: string) : string {
        console.log("Got message:", msg)
        return "some return value"
    }
}
```

7. QQuickView view(QUrl::fromLocalFile("MyItem.qml")); QObject *item = view.rootObject();

Получив rootObject() можно по id / objectName объектов ступскаться вгулбь по дереву объектов
и организовывать общение при помощи четырёх ранее описанных методов.

```
 signal qmlSignal(anObject: Item)
```

```
 void cppSlot(QQuickItem *item) {
       qDebug() << "Item dimensions:" << item->width() << item->height();
```

### Q: Casablanca c++Library for Rest ?

// TO DO


### Q: С++ 14 Стандарт ?
https://ru.wikipedia.org/wiki/C%2B%2B14
```
1	Изменения в языке
1.1	Вывод типа возвращаемого значения для функций
1.2	Альтернативный вывод типа при объявлении
1.3	Уменьшение ограничений на константные выражения
1.4	Шаблоны переменных
1.5	Агрегатная инициализация классов с инициализаторами полей
1.6	Литералы двоичных чисел
1.7	Разделители разрядов
1.8	Обобщённые лямбда-функции
1.9	Захват выражений для лямбда-функций
1.10	Атрибут [[deprecated]]
2	Новые функции стандартной библиотеки
2.1	Разделяемые мьютексы и блокировки
2.2	Гетерогенный поиск в ассоциативных контейнерах
2.3	Стандартные пользовательские литералы
2.4	Адресация к кортежам по типу
2.5	Прочие изменения стандартной библиотеки
3	Примечания
```
### Q: Плюсы и минусы СИНГЛТОН ?

- (+) Класс сам контролирует процесс создания единственного экземпляра.
- (+) Паттерн легко адаптировать для создания нужного числа экземпляров.
- (+) Возможность создания объектов классов, производных от Singleton.

- (-) В случае использования в нескольких потоках и нескольких взаимозависимых одиночек их реализация может резко усложниться.

### Q: Проблемы которые решает СИНГЛТОН ?

Проблема: В многопоточном приложении одновременно 2 или более потоков захотят вызвать функцию получения объекта синглтона с одним и тем же типом T?

https://habr.com/ru/post/150276/

1. Старый стандарт $6.7.4, C++03 - опускал какую либо информацию о многотопоточности при процессе инициализации объектов.
2. Новый стандарт  $6.7.4, C++11 - говорит о том, что если во время инициализации переменной (т.е. создания экземпляра) второй поток пытается получить доступ к этой же переменной, то он (поток) должен ожидать завершения инициализации, при этом реализация не должна допускать ситуации deadlock.

Вопрос остётся открытым лишь в том смысле - какие компиляторы действительно поддерживают новый стандарт, а какие лишь пытаются делать вид, что поддерживают. Что стоит проверять лишь экспериментально.

- (+) Ожидание (Как должно работать): Синглтон инициализируется только один раз и функция threadFunction завершает свою работу только после завершения инициализации синглтона => корректная инициализация объекта в многопоточном окружении.
- (-) Ошибка  (Негативный результат): Компилятор для первого потока начинает инициализировать синглтон, а для остальных — возвращает сразу объект, который даже не успел проинициализироваться => правильная работа в многопоточной среде может быть не обесепчена.

1. Улучшение - через mutex:
- перед созданием объекта мы будем использовать мьютекс для синхронизации доступа к объекту:
- (+) избавляет от проблемы возвращения неинициализированного объекта: перед началом инициализации вызывается mutex.lock(), а после завершения инициализации вызывается mutex.unlock(). Остальные потоки ожидают завершения инициализации перед тем, как начать его использовать. 
- (-) минус: блокировка используется всегда, вне зависимости от того, проинициализирован ли уже объект или нет. 

2. Улучшение - через "Double-Checked Locking Pattern":
- проверка условия: проинициализирован или нет? Если да — то сразу возвращаем ссылку на объект
- берем блокировку
- проверяем условие второй раз, если проинициализирован — то снимаем блокировку и возвращаем ссылку
- проводим инициализацию синглтона
- меняем условие на «проинициализирован»
- снимаем блокировку и возвращаем ссылку

3.1 Через класс SingletonDestroyer, для автоматического разрушения объекта Singleton.
3.2 Использование нескольких взаимозависимых одиночек

http://cpp-reference.ru/patterns/creational-patterns/singleton/

### Q: Потокобезопасность Синглтона Мейерса / Майерса ?
A: НЕ ПОТОКОБЕЗОПАСЕН - в его Традиционной реализации с отложенной инициализацией (lazy initialization). В современном C++11, этот паттерн считается ПОТОКОБЕЗОПАСНЫЙ, о чём написано в стандарте §6.7 [stmt.dcl] p4.

https://habr.com/ru/post/150276/

Из стандарта: If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.

- Visual Studio: supported since Visual Studio 2015
- GCC: supported since GCC 4.3

Ранее проблему решали с использованием метода "Double-Checked Locking" / "Double-Checked Locking Pattern", хоть он и был более затратен.
По причине возникновения такого решения, синглтон с использованием "Double-Checked Locking" назвали Синглтон Дейкстры.

```
In C++03, this code wasn't thread safe. There is an article by Meyers called 
"C++ and the Perils of Double-Checked Locking" which discusses thread safe 
implementations of the pattern, and the conclusion is, more or less, that 
(in C++03) full locking around the instantiating method is basically the 
simplest way to ensure proper concurrency on all platforms, while most forms 
of double-checked locking pattern variants may suffer from race conditions 
on certain architectures, unless instructions are interleaved with 
strategically places memory barriers.
```

### Q: Синглтон (небезопасный в многопоточном окружении) КОД
```
template<typename T>
T& single()
{
    static T t;
    return t;
}
```

### Q: Синглтон Класс (небезопасный в многопоточном окружении)
```
// Singleton.h
class Singleton
{
  private:
    static Singleton * p_instance;
    // Конструкторы и оператор присваивания недоступны клиентам
    Singleton() {}
    Singleton( const Singleton& );  
    Singleton& operator=( Singleton& );
  public:
    static Singleton * getInstance() {
        if(!p_instance)           
            p_instance = new Singleton();
        return p_instance;
    }
};
  
// Singleton.cpp
#include "Singleton.h"
  
Singleton* Singleton::p_instance = 0;
```

### Q: Синглтон Мейерса / Майерса (небезопасный в многопоточном окружении) КОД 
```
// Singleton.h
class Singleton
{
private: 
    Singleton() {}
    Singleton( const Singleton&);  
    Singleton& operator=( Singleton& );
public:
    static Singleton& getInstance() {
        static Singleton  instance;
        return instance;
    }    
}; 
```

### Q: Синглтон  DCLP (Double-Checked Locking Pattern) КОД
```
// небезопасная функция в многопоточном окружении
template<typename T>
T& singleUnsafe()
{
    static T t;
    return t;
}

// функция для использования в многопоточном окружении
template<typename T>
T& single()
{
	static T* volatile pt;
	if (pt == 0)
	{
		T* tmp;
		{
			StaticLock lock;
			tmp = &singleUnsafe<T>();
		}
		pt = tmp;
	}
	return *pt;
}
```
### Q: Синглтон Мейерса / Майерса КОД

// TO DO

### Q: Синглтон Дейкстры КОД

// TO DO

### Q: Синглтон Александреску КОД

// TO DO



# EED0CDB4-3867-4BED-BD73-0752E8D0184F

### Есть 2 строки из символов латинского алфавита, буквы в разном регстре строчные и прописные присуствуют, которые имеют одинаковую длину. Является ли одна строка перестановкой символов другой строки. Повторяющиеся символы присутствуют ?
Пример: 
1 строка автомобиль: automobile
2 строка  перемешка: abeilmootu

Решение:
2 МультиСэта заводим.
последовательно в каждый помещаем все элементы одной строки и второй строки. Сравниваем 2 заполненных мультисета.

https://tproger.ru/problems/method-to-decide-if-two-strings-are-anagrams-or-not/

### Метод, определяющий, является ли одна строка перестановкой другой

Способ 1. Сортировка строк.
Если строки являются анаграммами, то они состоят из одинаковых символов, расположенных в разном порядке. Сортировка двух строк должна упорядочить символы. Теперь остается только сравнить две отсортированные версии строк.
```
public String sort(String s) {
    char[] content = s.toCharArray();
    java.util.Arrays.sort(content);
    return new String(content);
}

public boolean permutation (String s,String t) {
    if (s.length() != t.length()) {
        return false;
    }
    return sort(s).equals(sort(t));
}
```

Способ 2. Проверка счетчиков идентичных символов.
Для реализации этого алгоритма можно использовать свойство анаграммы – одинаковые “счетчики” символов. Мы просто подсчитываем, сколько раз встречался каждый символ в строке. Затем сравниваем массивы, полученные для каждой строки.

Время работы второго способа O(n)

```
public boolean permutation(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }

    int[] letters = new int[256];

    char[] s_array = s.toCharArray();
    for (char c : s_array) {
        letters[c]++;
    }

    for (int i = 0; i < t.length(); i++) {
        int c = (int) t.charAt(i);
        if (--letters[c] < 0) {
            return false;
        }
    }

    return true;
}
```

